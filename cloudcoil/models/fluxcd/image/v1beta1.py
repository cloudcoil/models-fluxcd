# Generated by cloudcoil-model-codegen v0.2.1
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import Annotated, Callable, Dict, List, Literal, Optional, Type, Union

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import BaseBuilder, BaseModel, GenericListBuilder, Self
from cloudcoil.resources import Resource


class FilterTags(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["FilterTags"]:
            return FilterTags

        def build(self) -> "FilterTags":
            return FilterTags(**self._attrs)

        def extract(self, value: Optional[str]) -> Self:
            return self._set("extract", value)

        def pattern(self, value: Optional[str]) -> Self:
            return self._set("pattern", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["FilterTags", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FilterTags.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    extract: Annotated[
        Optional[str],
        Field(
            description="Extract allows a capture group to be extracted from the specified regular\nexpression pattern, useful before tag evaluation."
        ),
    ] = None
    pattern: Annotated[
        Optional[str],
        Field(
            description="Pattern specifies a regular expression pattern used to filter for image\ntags."
        ),
    ] = None


class ImageRepositoryRef(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["ImageRepositoryRef"]:
            return ImageRepositoryRef

        def build(self) -> "ImageRepositoryRef":
            return ImageRepositoryRef(**self._attrs)

        def name(self, value: str) -> Self:
            return self._set("name", value)

        def namespace(self, value: Optional[str]) -> Self:
            return self._set("namespace", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["ImageRepositoryRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageRepositoryRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Annotated[str, Field(description="Name of the referent.")]
    namespace: Annotated[
        Optional[str],
        Field(
            description="Namespace of the referent, when not specified it acts as LocalObjectReference."
        ),
    ] = None


class Alphabetical(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Alphabetical"]:
            return Alphabetical

        def build(self) -> "Alphabetical":
            return Alphabetical(**self._attrs)

        def order(self, value: Optional[Literal["asc", "desc"]]) -> Self:
            return self._set("order", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Alphabetical", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Alphabetical.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    order: Annotated[
        Optional[Literal["asc", "desc"]],
        Field(
            description="Order specifies the sorting order of the tags. Given the letters of the\nalphabet as tags, ascending order would select Z, and descending order\nwould select A."
        ),
    ] = "asc"


class Numerical(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Numerical"]:
            return Numerical

        def build(self) -> "Numerical":
            return Numerical(**self._attrs)

        def order(self, value: Optional[Literal["asc", "desc"]]) -> Self:
            return self._set("order", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Numerical", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Numerical.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    order: Annotated[
        Optional[Literal["asc", "desc"]],
        Field(
            description="Order specifies the sorting order of the tags. Given the integer values\nfrom 0 to 9 as tags, ascending order would select 9, and descending order\nwould select 0."
        ),
    ] = "asc"


class Semver(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Semver"]:
            return Semver

        def build(self) -> "Semver":
            return Semver(**self._attrs)

        def range(self, value: str) -> Self:
            return self._set("range", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Semver", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Semver.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    range: Annotated[
        str,
        Field(
            description="Range gives a semver range for the image tag; the highest\nversion within the range that's a tag yields the latest image."
        ),
    ]


class Policy(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Policy"]:
            return Policy

        def build(self) -> "Policy":
            return Policy(**self._attrs)

        def alphabetical(
            self,
            value_or_callback: Union[
                Optional[Alphabetical],
                Callable[[Alphabetical.Builder], Alphabetical.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Alphabetical.builder()).build()
            return self._set("alphabetical", value)

        def numerical(
            self,
            value_or_callback: Union[
                Optional[Numerical], Callable[[Numerical.Builder], Numerical.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Numerical.builder()).build()
            return self._set("numerical", value)

        def semver(
            self,
            value_or_callback: Union[Optional[Semver], Callable[[Semver.Builder], Semver.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Semver.builder()).build()
            return self._set("semver", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Policy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Policy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    alphabetical: Annotated[
        Optional[Alphabetical],
        Field(
            description="Alphabetical set of rules to use for alphabetical ordering of the tags."
        ),
    ] = None
    numerical: Annotated[
        Optional[Numerical],
        Field(description="Numerical set of rules to use for numerical ordering of the tags."),
    ] = None
    semver: Annotated[
        Optional[Semver],
        Field(
            description="SemVer gives a semantic version range to check against the tags\navailable."
        ),
    ] = None


class ImagePolicySpec(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["ImagePolicySpec"]:
            return ImagePolicySpec

        def build(self) -> "ImagePolicySpec":
            return ImagePolicySpec(**self._attrs)

        def filter_tags(
            self,
            value_or_callback: Union[
                Optional[FilterTags], Callable[[FilterTags.Builder], FilterTags.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(FilterTags.builder()).build()
            return self._set("filter_tags", value)

        def image_repository_ref(
            self,
            value_or_callback: Union[
                ImageRepositoryRef,
                Callable[[ImageRepositoryRef.Builder], ImageRepositoryRef.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(ImageRepositoryRef.builder()).build()
            return self._set("image_repository_ref", value)

        def policy(
            self,
            value_or_callback: Union[Policy, Callable[[Policy.Builder], Policy.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Policy.builder()).build()
            return self._set("policy", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["ImagePolicySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImagePolicySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    filter_tags: Annotated[
        Optional[FilterTags],
        Field(
            alias="filterTags",
            description="FilterTags enables filtering for only a subset of tags based on a set of\nrules. If no rules are provided, all the tags from the repository will be\nordered and compared.",
        ),
    ] = None
    image_repository_ref: Annotated[
        ImageRepositoryRef,
        Field(
            alias="imageRepositoryRef",
            description="ImageRepositoryRef points at the object specifying the image\nbeing scanned",
        ),
    ]
    policy: Annotated[
        Policy,
        Field(
            description="Policy gives the particulars of the policy to be followed in\nselecting the most recent image"
        ),
    ]


class Condition(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: datetime) -> Self:
            return self._set("last_transition_time", value)

        def message(self, value: str) -> Self:
            return self._set("message", value)

        def observed_generation(self, value: Optional[int]) -> Self:
            return self._set("observed_generation", value)

        def reason(self, value: str) -> Self:
            return self._set("reason", value)

        def status(self, value: Literal["True", "False", "Unknown"]) -> Self:
            return self._set("status", value)

        def type(self, value: str) -> Self:
            return self._set("type", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[
        datetime,
        Field(
            alias="lastTransitionTime",
            description="lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
        ),
    ]
    message: Annotated[
        str,
        Field(
            description="message is a human readable message indicating details about the transition.\nThis may be an empty string.",
            max_length=32768,
        ),
    ]
    observed_generation: Annotated[
        Optional[int],
        Field(
            alias="observedGeneration",
            description="observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
            ge=0,
        ),
    ] = None
    reason: Annotated[
        str,
        Field(
            description="reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.",
            max_length=1024,
            min_length=1,
            pattern="^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$",
        ),
    ]
    status: Annotated[
        Literal["True", "False", "Unknown"],
        Field(description="status of the condition, one of True, False, Unknown."),
    ]
    type: Annotated[
        str,
        Field(
            description="type of condition in CamelCase or in foo.example.com/CamelCase.",
            max_length=316,
            pattern="^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$",
        ),
    ]


class ImagePolicyStatus(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["ImagePolicyStatus"]:
            return ImagePolicyStatus

        def build(self) -> "ImagePolicyStatus":
            return ImagePolicyStatus(**self._attrs)

        def conditions(
            self,
            value_or_callback: Union[
                Optional[List[Condition]],
                Callable[
                    [GenericListBuilder[Condition, Condition.Builder]],
                    GenericListBuilder[Condition, Condition.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Condition.list_builder()).build()
            return self._set("conditions", value)

        def latest_image(self, value: Optional[str]) -> Self:
            return self._set("latest_image", value)

        def observed_generation(self, value: Optional[int]) -> Self:
            return self._set("observed_generation", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["ImagePolicyStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImagePolicyStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    latest_image: Annotated[
        Optional[str],
        Field(
            alias="latestImage",
            description="LatestImage gives the first in the list of images scanned by\nthe image repository, when filtered and ordered according to\nthe policy.",
        ),
    ] = None
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None


class NamespaceSelector(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["NamespaceSelector"]:
            return NamespaceSelector

        def build(self) -> "NamespaceSelector":
            return NamespaceSelector(**self._attrs)

        def match_labels(self, value: Optional[Dict[str, str]]) -> Self:
            return self._set("match_labels", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["NamespaceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamespaceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_labels: Annotated[
        Optional[Dict[str, str]],
        Field(
            alias="matchLabels",
            description='MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is "key", the\noperator is "In", and the values array contains only "value". The requirements are ANDed.',
        ),
    ] = None


class AccessFrom(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["AccessFrom"]:
            return AccessFrom

        def build(self) -> "AccessFrom":
            return AccessFrom(**self._attrs)

        def namespace_selectors(
            self,
            value_or_callback: Union[
                List[NamespaceSelector],
                Callable[
                    [GenericListBuilder[NamespaceSelector, NamespaceSelector.Builder]],
                    GenericListBuilder[NamespaceSelector, NamespaceSelector.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(NamespaceSelector.list_builder()).build()
            return self._set("namespace_selectors", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["AccessFrom", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AccessFrom.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    namespace_selectors: Annotated[
        List[NamespaceSelector],
        Field(
            alias="namespaceSelectors",
            description="NamespaceSelectors is the list of namespace selectors to which this ACL applies.\nItems in this list are evaluated using a logical OR operation.",
        ),
    ]


class CertSecretRef(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["CertSecretRef"]:
            return CertSecretRef

        def build(self) -> "CertSecretRef":
            return CertSecretRef(**self._attrs)

        def name(self, value: str) -> Self:
            return self._set("name", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["CertSecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CertSecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Annotated[str, Field(description="Name of the referent.")]


class SecretRef(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["SecretRef"]:
            return SecretRef

        def build(self) -> "SecretRef":
            return SecretRef(**self._attrs)

        def name(self, value: str) -> Self:
            return self._set("name", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["SecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Annotated[str, Field(description="Name of the referent.")]


class ImageRepositorySpec(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["ImageRepositorySpec"]:
            return ImageRepositorySpec

        def build(self) -> "ImageRepositorySpec":
            return ImageRepositorySpec(**self._attrs)

        def access_from(
            self,
            value_or_callback: Union[
                Optional[AccessFrom], Callable[[AccessFrom.Builder], AccessFrom.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(AccessFrom.builder()).build()
            return self._set("access_from", value)

        def cert_secret_ref(
            self,
            value_or_callback: Union[
                Optional[CertSecretRef],
                Callable[[CertSecretRef.Builder], CertSecretRef.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(CertSecretRef.builder()).build()
            return self._set("cert_secret_ref", value)

        def exclusion_list(self, value: Optional[List[str]]) -> Self:
            return self._set("exclusion_list", value)

        def image(self, value: str) -> Self:
            return self._set("image", value)

        def interval(self, value: str) -> Self:
            return self._set("interval", value)

        def secret_ref(
            self,
            value_or_callback: Union[
                Optional[SecretRef], Callable[[SecretRef.Builder], SecretRef.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SecretRef.builder()).build()
            return self._set("secret_ref", value)

        def service_account_name(self, value: Optional[str]) -> Self:
            return self._set("service_account_name", value)

        def suspend(self, value: Optional[bool]) -> Self:
            return self._set("suspend", value)

        def timeout(self, value: Optional[str]) -> Self:
            return self._set("timeout", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["ImageRepositorySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageRepositorySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_from: Annotated[
        Optional[AccessFrom],
        Field(
            alias="accessFrom",
            description="AccessFrom defines an ACL for allowing cross-namespace references\nto the ImageRepository object based on the caller's namespace labels.",
        ),
    ] = None
    cert_secret_ref: Annotated[
        Optional[CertSecretRef],
        Field(
            alias="certSecretRef",
            description="CertSecretRef can be given the name of a secret containing\neither or both of\n\n - a PEM-encoded client certificate (`certFile`) and private\n key (`keyFile`);\n - a PEM-encoded CA certificate (`caFile`)\n\n and whichever are supplied, will be used for connecting to the\n registry. The client cert and key are useful if you are\n authenticating with a certificate; the CA cert is useful if\n you are using a self-signed server certificate.",
        ),
    ] = None
    exclusion_list: Annotated[
        Optional[List[str]],
        Field(
            alias="exclusionList",
            description="ExclusionList is a list of regex strings used to exclude certain tags\nfrom being stored in the database.",
        ),
    ] = None
    image: Annotated[str, Field(description="Image is the name of the image repository")]
    interval: Annotated[
        str,
        Field(
            description="Interval is the length of time to wait between\nscans of the image repository.",
            pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$",
        ),
    ]
    secret_ref: Annotated[
        Optional[SecretRef],
        Field(
            alias="secretRef",
            description="SecretRef can be given the name of a secret containing\ncredentials to use for the image registry. The secret should be\ncreated with `kubectl create secret docker-registry`, or the\nequivalent.",
        ),
    ] = None
    service_account_name: Annotated[
        Optional[str],
        Field(
            alias="serviceAccountName",
            description="ServiceAccountName is the name of the Kubernetes ServiceAccount used to authenticate\nthe image pull if the service account has attached pull secrets.",
            max_length=253,
        ),
    ] = None
    suspend: Annotated[
        Optional[bool],
        Field(
            description="This flag tells the controller to suspend subsequent image scans.\nIt does not apply to already started scans. Defaults to false."
        ),
    ] = None
    timeout: Annotated[
        Optional[str],
        Field(
            description="Timeout for image scanning.\nDefaults to 'Interval' duration.",
            pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m))+$",
        ),
    ] = None


class LastScanResult(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["LastScanResult"]:
            return LastScanResult

        def build(self) -> "LastScanResult":
            return LastScanResult(**self._attrs)

        def scan_time(self, value: Optional[datetime]) -> Self:
            return self._set("scan_time", value)

        def tag_count(self, value: int) -> Self:
            return self._set("tag_count", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["LastScanResult", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LastScanResult.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    scan_time: Annotated[Optional[datetime], Field(alias="scanTime")] = None
    tag_count: Annotated[int, Field(alias="tagCount")]


class ImageRepositoryStatus(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["ImageRepositoryStatus"]:
            return ImageRepositoryStatus

        def build(self) -> "ImageRepositoryStatus":
            return ImageRepositoryStatus(**self._attrs)

        def canonical_image_name(self, value: Optional[str]) -> Self:
            return self._set("canonical_image_name", value)

        def conditions(
            self,
            value_or_callback: Union[
                Optional[List[Condition]],
                Callable[
                    [GenericListBuilder[Condition, Condition.Builder]],
                    GenericListBuilder[Condition, Condition.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Condition.list_builder()).build()
            return self._set("conditions", value)

        def last_handled_reconcile_at(self, value: Optional[str]) -> Self:
            return self._set("last_handled_reconcile_at", value)

        def last_scan_result(
            self,
            value_or_callback: Union[
                Optional[LastScanResult],
                Callable[[LastScanResult.Builder], LastScanResult.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(LastScanResult.builder()).build()
            return self._set("last_scan_result", value)

        def observed_generation(self, value: Optional[int]) -> Self:
            return self._set("observed_generation", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["ImageRepositoryStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageRepositoryStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    canonical_image_name: Annotated[
        Optional[str],
        Field(
            alias="canonicalImageName",
            description="CanonicalName is the name of the image repository with all the\nimplied bits made explicit; e.g., `docker.io/library/alpine`\nrather than `alpine`.",
        ),
    ] = None
    conditions: Optional[List[Condition]] = None
    last_handled_reconcile_at: Annotated[
        Optional[str],
        Field(
            alias="lastHandledReconcileAt",
            description="LastHandledReconcileAt holds the value of the most recent\nreconcile request value, so a change of the annotation value\ncan be detected.",
        ),
    ] = None
    last_scan_result: Annotated[
        Optional[LastScanResult],
        Field(
            alias="lastScanResult",
            description="LastScanResult contains the number of fetched tags.",
        ),
    ] = None
    observed_generation: Annotated[
        Optional[int],
        Field(
            alias="observedGeneration",
            description="ObservedGeneration is the last reconciled generation.",
        ),
    ] = None


class Ref(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Ref"]:
            return Ref

        def build(self) -> "Ref":
            return Ref(**self._attrs)

        def branch(self, value: Optional[str]) -> Self:
            return self._set("branch", value)

        def commit(self, value: Optional[str]) -> Self:
            return self._set("commit", value)

        def name(self, value: Optional[str]) -> Self:
            return self._set("name", value)

        def semver(self, value: Optional[str]) -> Self:
            return self._set("semver", value)

        def tag(self, value: Optional[str]) -> Self:
            return self._set("tag", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Ref", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ref.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    branch: Annotated[
        Optional[str],
        Field(
            description="Branch to check out, defaults to 'master' if no other field is defined."
        ),
    ] = None
    commit: Annotated[
        Optional[str],
        Field(
            description="Commit SHA to check out, takes precedence over all reference fields.\n\nThis can be combined with Branch to shallow clone the branch, in which\nthe commit is expected to exist."
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description='Name of the reference to check out; takes precedence over Branch, Tag and SemVer.\n\nIt must be a valid Git reference: https://git-scm.com/docs/git-check-ref-format#_description\nExamples: "refs/heads/main", "refs/tags/v0.1.0", "refs/pull/420/head", "refs/merge-requests/1/head"'
        ),
    ] = None
    semver: Annotated[
        Optional[str],
        Field(description="SemVer tag expression to check out, takes precedence over Tag."),
    ] = None
    tag: Annotated[
        Optional[str],
        Field(description="Tag to check out, takes precedence over Branch."),
    ] = None


class Checkout(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Checkout"]:
            return Checkout

        def build(self) -> "Checkout":
            return Checkout(**self._attrs)

        def ref(self, value_or_callback: Union[Ref, Callable[[Ref.Builder], Ref.Builder]]) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Ref.builder()).build()
            return self._set("ref", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Checkout", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Checkout.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Annotated[
        Ref,
        Field(
            description="Reference gives a branch, tag or commit to clone from the Git\nrepository."
        ),
    ]


class Author(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Author"]:
            return Author

        def build(self) -> "Author":
            return Author(**self._attrs)

        def email(self, value: str) -> Self:
            return self._set("email", value)

        def name(self, value: Optional[str]) -> Self:
            return self._set("name", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Author", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Author.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    email: Annotated[
        str, Field(description="Email gives the email to provide when making a commit.")
    ]
    name: Annotated[
        Optional[str],
        Field(description="Name gives the name to provide when making a commit."),
    ] = None


class SigningKey(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["SigningKey"]:
            return SigningKey

        def build(self) -> "SigningKey":
            return SigningKey(**self._attrs)

        def secret_ref(
            self,
            value_or_callback: Union[SecretRef, Callable[[SecretRef.Builder], SecretRef.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SecretRef.builder()).build()
            return self._set("secret_ref", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["SigningKey", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SigningKey.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secret_ref: Annotated[
        SecretRef,
        Field(
            alias="secretRef",
            description="SecretRef holds the name to a secret that contains a 'git.asc' key\ncorresponding to the ASCII Armored file containing the GPG signing\nkeypair as the value. It must be in the same namespace as the\nImageUpdateAutomation.",
        ),
    ]


class Commit(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Commit"]:
            return Commit

        def build(self) -> "Commit":
            return Commit(**self._attrs)

        def author(
            self,
            value_or_callback: Union[Author, Callable[[Author.Builder], Author.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Author.builder()).build()
            return self._set("author", value)

        def message_template(self, value: Optional[str]) -> Self:
            return self._set("message_template", value)

        def signing_key(
            self,
            value_or_callback: Union[
                Optional[SigningKey], Callable[[SigningKey.Builder], SigningKey.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SigningKey.builder()).build()
            return self._set("signing_key", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Commit", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Commit.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    author: Annotated[
        Author,
        Field(
            description="Author gives the email and optionally the name to use as the\nauthor of commits."
        ),
    ]
    message_template: Annotated[
        Optional[str],
        Field(
            alias="messageTemplate",
            description="MessageTemplate provides a template for the commit message,\ninto which will be interpolated the details of the change made.",
        ),
    ] = None
    signing_key: Annotated[
        Optional[SigningKey],
        Field(
            alias="signingKey",
            description="SigningKey provides the option to sign commits with a GPG key",
        ),
    ] = None


class Push(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Push"]:
            return Push

        def build(self) -> "Push":
            return Push(**self._attrs)

        def branch(self, value: Optional[str]) -> Self:
            return self._set("branch", value)

        def options(self, value: Optional[Dict[str, str]]) -> Self:
            return self._set("options", value)

        def refspec(self, value: Optional[str]) -> Self:
            return self._set("refspec", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Push", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Push.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    branch: Annotated[
        Optional[str],
        Field(
            description="Branch specifies that commits should be pushed to the branch\nnamed. The branch is created using `.spec.checkout.branch` as the\nstarting point, if it doesn't already exist."
        ),
    ] = None
    options: Annotated[
        Optional[Dict[str, str]],
        Field(
            description="Options specifies the push options that are sent to the Git\nserver when performing a push operation. For details, see:\nhttps://git-scm.com/docs/git-push#Documentation/git-push.txt---push-optionltoptiongt"
        ),
    ] = None
    refspec: Annotated[
        Optional[str],
        Field(
            description="Refspec specifies the Git Refspec to use for a push operation.\nIf both Branch and Refspec are provided, then the commit is pushed\nto the branch and also using the specified refspec.\nFor more details about Git Refspecs, see:\nhttps://git-scm.com/book/en/v2/Git-Internals-The-Refspec"
        ),
    ] = None


class Git(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Git"]:
            return Git

        def build(self) -> "Git":
            return Git(**self._attrs)

        def checkout(
            self,
            value_or_callback: Union[
                Optional[Checkout], Callable[[Checkout.Builder], Checkout.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Checkout.builder()).build()
            return self._set("checkout", value)

        def commit(
            self,
            value_or_callback: Union[Commit, Callable[[Commit.Builder], Commit.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Commit.builder()).build()
            return self._set("commit", value)

        def push(
            self,
            value_or_callback: Union[Optional[Push], Callable[[Push.Builder], Push.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Push.builder()).build()
            return self._set("push", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Git", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Git.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    checkout: Annotated[
        Optional[Checkout],
        Field(
            description="Checkout gives the parameters for cloning the git repository,\nready to make changes. If not present, the `spec.ref` field from the\nreferenced `GitRepository` or its default will be used."
        ),
    ] = None
    commit: Annotated[
        Commit,
        Field(description="Commit specifies how to commit to the git repository."),
    ]
    push: Annotated[
        Optional[Push],
        Field(
            description="Push specifies how and where to push commits made by the\nautomation. If missing, commits are pushed (back) to\n`.spec.checkout.branch` or its default."
        ),
    ] = None


class SourceRef(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["SourceRef"]:
            return SourceRef

        def build(self) -> "SourceRef":
            return SourceRef(**self._attrs)

        def api_version(self, value: Optional[str]) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["GitRepository"]]) -> Self:
            return self._set("kind", value)

        def name(self, value: str) -> Self:
            return self._set("name", value)

        def namespace(self, value: Optional[str]) -> Self:
            return self._set("namespace", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["SourceRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SourceRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[str],
        Field(alias="apiVersion", description="API version of the referent."),
    ] = None
    kind: Annotated[
        Optional[Literal["GitRepository"]], Field(description="Kind of the referent.")
    ] = "GitRepository"
    name: Annotated[str, Field(description="Name of the referent.")]
    namespace: Annotated[
        Optional[str],
        Field(
            description="Namespace of the referent, defaults to the namespace of the Kubernetes resource object that contains the reference."
        ),
    ] = None


class Update(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Update"]:
            return Update

        def build(self) -> "Update":
            return Update(**self._attrs)

        def path(self, value: Optional[str]) -> Self:
            return self._set("path", value)

        def strategy(self, value: Optional[Literal["Setters"]]) -> Self:
            return self._set("strategy", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Update", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Update.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    path: Annotated[
        Optional[str],
        Field(
            description="Path to the directory containing the manifests to be updated.\nDefaults to 'None', which translates to the root path\nof the GitRepositoryRef."
        ),
    ] = None
    strategy: Annotated[
        Optional[Literal["Setters"]],
        Field(description="Strategy names the strategy to be used."),
    ] = "Setters"


class ImageUpdateAutomationSpec(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["ImageUpdateAutomationSpec"]:
            return ImageUpdateAutomationSpec

        def build(self) -> "ImageUpdateAutomationSpec":
            return ImageUpdateAutomationSpec(**self._attrs)

        def git(
            self,
            value_or_callback: Union[Optional[Git], Callable[[Git.Builder], Git.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Git.builder()).build()
            return self._set("git", value)

        def interval(self, value: str) -> Self:
            return self._set("interval", value)

        def source_ref(
            self,
            value_or_callback: Union[SourceRef, Callable[[SourceRef.Builder], SourceRef.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SourceRef.builder()).build()
            return self._set("source_ref", value)

        def suspend(self, value: Optional[bool]) -> Self:
            return self._set("suspend", value)

        def update(
            self,
            value_or_callback: Union[Optional[Update], Callable[[Update.Builder], Update.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Update.builder()).build()
            return self._set("update", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["ImageUpdateAutomationSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageUpdateAutomationSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    git: Annotated[
        Optional[Git],
        Field(
            description="GitSpec contains all the git-specific definitions. This is\ntechnically optional, but in practice mandatory until there are\nother kinds of source allowed."
        ),
    ] = None
    interval: Annotated[
        str,
        Field(
            description="Interval gives an lower bound for how often the automation\nrun should be attempted.",
            pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$",
        ),
    ]
    source_ref: Annotated[
        SourceRef,
        Field(
            alias="sourceRef",
            description="SourceRef refers to the resource giving access details\nto a git repository.",
        ),
    ]
    suspend: Annotated[
        Optional[bool],
        Field(
            description="Suspend tells the controller to not run this automation, until\nit is unset (or set to false). Defaults to false."
        ),
    ] = None
    update: Annotated[
        Optional[Update],
        Field(
            description="Update gives the specification for how to update the files in\nthe repository. This can be left empty, to use the default\nvalue."
        ),
    ] = {"strategy": "Setters"}


class ImageUpdateAutomationStatus(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["ImageUpdateAutomationStatus"]:
            return ImageUpdateAutomationStatus

        def build(self) -> "ImageUpdateAutomationStatus":
            return ImageUpdateAutomationStatus(**self._attrs)

        def conditions(
            self,
            value_or_callback: Union[
                Optional[List[Condition]],
                Callable[
                    [GenericListBuilder[Condition, Condition.Builder]],
                    GenericListBuilder[Condition, Condition.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Condition.list_builder()).build()
            return self._set("conditions", value)

        def last_automation_run_time(self, value: Optional[datetime]) -> Self:
            return self._set("last_automation_run_time", value)

        def last_handled_reconcile_at(self, value: Optional[str]) -> Self:
            return self._set("last_handled_reconcile_at", value)

        def last_push_commit(self, value: Optional[str]) -> Self:
            return self._set("last_push_commit", value)

        def last_push_time(self, value: Optional[datetime]) -> Self:
            return self._set("last_push_time", value)

        def observed_generation(self, value: Optional[int]) -> Self:
            return self._set("observed_generation", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["ImageUpdateAutomationStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageUpdateAutomationStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    last_automation_run_time: Annotated[
        Optional[datetime],
        Field(
            alias="lastAutomationRunTime",
            description="LastAutomationRunTime records the last time the controller ran\nthis automation through to completion (even if no updates were\nmade).",
        ),
    ] = None
    last_handled_reconcile_at: Annotated[
        Optional[str],
        Field(
            alias="lastHandledReconcileAt",
            description="LastHandledReconcileAt holds the value of the most recent\nreconcile request value, so a change of the annotation value\ncan be detected.",
        ),
    ] = None
    last_push_commit: Annotated[
        Optional[str],
        Field(
            alias="lastPushCommit",
            description="LastPushCommit records the SHA1 of the last commit made by the\ncontroller, for this automation object",
        ),
    ] = None
    last_push_time: Annotated[
        Optional[datetime],
        Field(
            alias="lastPushTime",
            description="LastPushTime records the time of the last pushed change.",
        ),
    ] = None
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None


class ImagePolicy(Resource):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["ImagePolicy"]:
            return ImagePolicy

        def build(self) -> "ImagePolicy":
            return ImagePolicy(**self._attrs)

        def api_version(self, value: Optional[Literal["image.toolkit.fluxcd.io/v1beta1"]]) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ImagePolicy"]]) -> Self:
            return self._set("kind", value)

        def metadata(
            self,
            value_or_callback: Union[
                Optional[apimachinery.ObjectMeta],
                Callable[[apimachinery.ObjectMeta.Builder], apimachinery.ObjectMeta.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(apimachinery.ObjectMeta.builder()).build()
            return self._set("metadata", value)

        def spec(
            self,
            value_or_callback: Union[
                Optional[ImagePolicySpec],
                Callable[[ImagePolicySpec.Builder], ImagePolicySpec.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(ImagePolicySpec.builder()).build()
            return self._set("spec", value)

        def status(
            self,
            value_or_callback: Union[
                Optional[ImagePolicyStatus],
                Callable[[ImagePolicyStatus.Builder], ImagePolicyStatus.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(ImagePolicyStatus.builder()).build()
            return self._set("status", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["ImagePolicy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImagePolicy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["image.toolkit.fluxcd.io/v1beta1"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "image.toolkit.fluxcd.io/v1beta1"
    kind: Annotated[
        Optional[Literal["ImagePolicy"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "ImagePolicy"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[ImagePolicySpec] = None
    status: Optional[ImagePolicyStatus] = None


class ImageRepository(Resource):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["ImageRepository"]:
            return ImageRepository

        def build(self) -> "ImageRepository":
            return ImageRepository(**self._attrs)

        def api_version(self, value: Optional[Literal["image.toolkit.fluxcd.io/v1beta1"]]) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ImageRepository"]]) -> Self:
            return self._set("kind", value)

        def metadata(
            self,
            value_or_callback: Union[
                Optional[apimachinery.ObjectMeta],
                Callable[[apimachinery.ObjectMeta.Builder], apimachinery.ObjectMeta.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(apimachinery.ObjectMeta.builder()).build()
            return self._set("metadata", value)

        def spec(
            self,
            value_or_callback: Union[
                Optional[ImageRepositorySpec],
                Callable[[ImageRepositorySpec.Builder], ImageRepositorySpec.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(ImageRepositorySpec.builder()).build()
            return self._set("spec", value)

        def status(
            self,
            value_or_callback: Union[
                Optional[ImageRepositoryStatus],
                Callable[[ImageRepositoryStatus.Builder], ImageRepositoryStatus.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(ImageRepositoryStatus.builder()).build()
            return self._set("status", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["ImageRepository", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageRepository.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["image.toolkit.fluxcd.io/v1beta1"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "image.toolkit.fluxcd.io/v1beta1"
    kind: Annotated[
        Optional[Literal["ImageRepository"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "ImageRepository"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[ImageRepositorySpec] = None
    status: Optional[ImageRepositoryStatus] = None


class ImageUpdateAutomation(Resource):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["ImageUpdateAutomation"]:
            return ImageUpdateAutomation

        def build(self) -> "ImageUpdateAutomation":
            return ImageUpdateAutomation(**self._attrs)

        def api_version(self, value: Optional[Literal["image.toolkit.fluxcd.io/v1beta1"]]) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ImageUpdateAutomation"]]) -> Self:
            return self._set("kind", value)

        def metadata(
            self,
            value_or_callback: Union[
                Optional[apimachinery.ObjectMeta],
                Callable[[apimachinery.ObjectMeta.Builder], apimachinery.ObjectMeta.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(apimachinery.ObjectMeta.builder()).build()
            return self._set("metadata", value)

        def spec(
            self,
            value_or_callback: Union[
                Optional[ImageUpdateAutomationSpec],
                Callable[
                    [ImageUpdateAutomationSpec.Builder],
                    ImageUpdateAutomationSpec.Builder,
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(ImageUpdateAutomationSpec.builder()).build()
            return self._set("spec", value)

        def status(
            self,
            value_or_callback: Union[
                Optional[ImageUpdateAutomationStatus],
                Callable[
                    [ImageUpdateAutomationStatus.Builder],
                    ImageUpdateAutomationStatus.Builder,
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(ImageUpdateAutomationStatus.builder()).build()
            return self._set("status", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["ImageUpdateAutomation", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageUpdateAutomation.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["image.toolkit.fluxcd.io/v1beta1"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "image.toolkit.fluxcd.io/v1beta1"
    kind: Annotated[
        Optional[Literal["ImageUpdateAutomation"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "ImageUpdateAutomation"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[ImageUpdateAutomationSpec] = None
    status: Optional[ImageUpdateAutomationStatus] = None
