# Generated by cloudcoil-model-codegen v0.2.1
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    Union,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import BaseBuilder, BaseModel, GenericListBuilder, Self
from cloudcoil.resources import Resource


class SecretRef(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["SecretRef"]:
            return SecretRef

        def build(self) -> "SecretRef":
            return SecretRef(**self._attrs)

        def name(self, value: str) -> Self:
            return self._set("name", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["SecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Annotated[str, Field(description="Name of the referent.")]


class Decryption(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Decryption"]:
            return Decryption

        def build(self) -> "Decryption":
            return Decryption(**self._attrs)

        def provider(self, value: Literal["sops"]) -> Self:
            return self._set("provider", value)

        def secret_ref(
            self,
            value_or_callback: Union[
                Optional[SecretRef], Callable[[SecretRef.Builder], SecretRef.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SecretRef.builder()).build()
            return self._set("secret_ref", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Decryption", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Decryption.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    provider: Annotated[
        Literal["sops"],
        Field(description="Provider is the name of the decryption engine."),
    ]
    secret_ref: Annotated[
        Optional[SecretRef],
        Field(
            alias="secretRef",
            description="The secret name containing the private OpenPGP keys used for decryption.",
        ),
    ] = None


class DependsOn(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["DependsOn"]:
            return DependsOn

        def build(self) -> "DependsOn":
            return DependsOn(**self._attrs)

        def name(self, value: str) -> Self:
            return self._set("name", value)

        def namespace(self, value: Optional[str]) -> Self:
            return self._set("namespace", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["DependsOn", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DependsOn.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Annotated[str, Field(description="Name of the referent.")]
    namespace: Annotated[
        Optional[str],
        Field(
            description="Namespace of the referent, when not specified it acts as LocalObjectReference."
        ),
    ] = None


class HealthCheck(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["HealthCheck"]:
            return HealthCheck

        def build(self) -> "HealthCheck":
            return HealthCheck(**self._attrs)

        def api_version(self, value: Optional[str]) -> Self:
            return self._set("api_version", value)

        def kind(self, value: str) -> Self:
            return self._set("kind", value)

        def name(self, value: str) -> Self:
            return self._set("name", value)

        def namespace(self, value: Optional[str]) -> Self:
            return self._set("namespace", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["HealthCheck", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HealthCheck.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[str],
        Field(
            alias="apiVersion",
            description="API version of the referent, if not specified the Kubernetes preferred version will be used.",
        ),
    ] = None
    kind: Annotated[str, Field(description="Kind of the referent.")]
    name: Annotated[str, Field(description="Name of the referent.")]
    namespace: Annotated[
        Optional[str],
        Field(
            description="Namespace of the referent, when not specified it acts as LocalObjectReference."
        ),
    ] = None


class Image(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Image"]:
            return Image

        def build(self) -> "Image":
            return Image(**self._attrs)

        def digest(self, value: Optional[str]) -> Self:
            return self._set("digest", value)

        def name(self, value: str) -> Self:
            return self._set("name", value)

        def new_name(self, value: Optional[str]) -> Self:
            return self._set("new_name", value)

        def new_tag(self, value: Optional[str]) -> Self:
            return self._set("new_tag", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Image", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Image.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    digest: Annotated[
        Optional[str],
        Field(
            description="Digest is the value used to replace the original image tag.\nIf digest is present NewTag value is ignored."
        ),
    ] = None
    name: Annotated[str, Field(description="Name is a tag-less image name.")]
    new_name: Annotated[
        Optional[str],
        Field(
            alias="newName",
            description="NewName is the value used to replace the original name.",
        ),
    ] = None
    new_tag: Annotated[
        Optional[str],
        Field(
            alias="newTag",
            description="NewTag is the value used to replace the original tag.",
        ),
    ] = None


class KubeConfig(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["KubeConfig"]:
            return KubeConfig

        def build(self) -> "KubeConfig":
            return KubeConfig(**self._attrs)

        def secret_ref(
            self,
            value_or_callback: Union[SecretRef, Callable[[SecretRef.Builder], SecretRef.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SecretRef.builder()).build()
            return self._set("secret_ref", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["KubeConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KubeConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secret_ref: Annotated[
        SecretRef,
        Field(
            alias="secretRef",
            description="SecretRef holds the name to a secret that contains a 'value' key with\nthe kubeconfig file as the value. It must be in the same namespace as\nthe Kustomization.\nIt is recommended that the kubeconfig is self-contained, and the secret\nis regularly updated if credentials such as a cloud-access-token expire.\nCloud specific `cmd-path` auth helpers will not function without adding\nbinaries and credentials to the Pod that is responsible for reconciling\nthe Kustomization.",
        ),
    ]


class Target(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Target"]:
            return Target

        def build(self) -> "Target":
            return Target(**self._attrs)

        def annotation_selector(self, value: Optional[str]) -> Self:
            return self._set("annotation_selector", value)

        def group(self, value: Optional[str]) -> Self:
            return self._set("group", value)

        def kind(self, value: Optional[str]) -> Self:
            return self._set("kind", value)

        def label_selector(self, value: Optional[str]) -> Self:
            return self._set("label_selector", value)

        def name(self, value: Optional[str]) -> Self:
            return self._set("name", value)

        def namespace(self, value: Optional[str]) -> Self:
            return self._set("namespace", value)

        def version(self, value: Optional[str]) -> Self:
            return self._set("version", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Target", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Target.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotation_selector: Annotated[
        Optional[str],
        Field(
            alias="annotationSelector",
            description="AnnotationSelector is a string that follows the label selection expression\nhttps://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api\nIt matches with the resource annotations.",
        ),
    ] = None
    group: Annotated[
        Optional[str],
        Field(
            description="Group is the API group to select resources from.\nTogether with Version and Kind it is capable of unambiguously identifying and/or selecting resources.\nhttps://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md"
        ),
    ] = None
    kind: Annotated[
        Optional[str],
        Field(
            description="Kind of the API Group to select resources from.\nTogether with Group and Version it is capable of unambiguously\nidentifying and/or selecting resources.\nhttps://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md"
        ),
    ] = None
    label_selector: Annotated[
        Optional[str],
        Field(
            alias="labelSelector",
            description="LabelSelector is a string that follows the label selection expression\nhttps://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api\nIt matches with the resource labels.",
        ),
    ] = None
    name: Annotated[Optional[str], Field(description="Name to match resources with.")] = None
    namespace: Annotated[
        Optional[str], Field(description="Namespace to select resources from.")
    ] = None
    version: Annotated[
        Optional[str],
        Field(
            description="Version of the API Group to select resources from.\nTogether with Group and Kind it is capable of unambiguously identifying and/or selecting resources.\nhttps://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md"
        ),
    ] = None


class Patch(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Patch"]:
            return Patch

        def build(self) -> "Patch":
            return Patch(**self._attrs)

        def patch(self, value: str) -> Self:
            return self._set("patch", value)

        def target(
            self,
            value_or_callback: Union[Optional[Target], Callable[[Target.Builder], Target.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Target.builder()).build()
            return self._set("target", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Patch", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Patch.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    patch: Annotated[
        str,
        Field(
            description="Patch contains an inline StrategicMerge patch or an inline JSON6902 patch with\nan array of operation objects."
        ),
    ]
    target: Annotated[
        Optional[Target],
        Field(
            description="Target points to the resources that the patch document should be applied to."
        ),
    ] = None


class PatchModel(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["PatchModel"]:
            return PatchModel

        def build(self) -> "PatchModel":
            return PatchModel(**self._attrs)

        def from_(self, value: Optional[str]) -> Self:
            return self._set("from_", value)

        def op(self, value: Literal["test", "remove", "add", "replace", "move", "copy"]) -> Self:
            return self._set("op", value)

        def path(self, value: str) -> Self:
            return self._set("path", value)

        def value(self, value: Optional[Any]) -> Self:
            return self._set("value", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["PatchModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PatchModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    from_: Annotated[
        Optional[str],
        Field(
            alias="from",
            description="From contains a JSON-pointer value that references a location within the target document where the operation is\nperformed. The meaning of the value depends on the value of Op, and is NOT taken into account by all operations.",
        ),
    ] = None
    op: Annotated[
        Literal["test", "remove", "add", "replace", "move", "copy"],
        Field(
            description='Op indicates the operation to perform. Its value MUST be one of "add", "remove", "replace", "move", "copy", or\n"test".\nhttps://datatracker.ietf.org/doc/html/rfc6902#section-4'
        ),
    ]
    path: Annotated[
        str,
        Field(
            description="Path contains the JSON-pointer value that references a location within the target document where the operation\nis performed. The meaning of the value depends on the value of Op."
        ),
    ]
    value: Annotated[
        Optional[Any],
        Field(
            description="Value contains a valid JSON structure. The meaning of the value depends on the value of Op, and is NOT taken into\naccount by all operations."
        ),
    ] = None


class PatchesJson6902(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["PatchesJson6902"]:
            return PatchesJson6902

        def build(self) -> "PatchesJson6902":
            return PatchesJson6902(**self._attrs)

        def patch(
            self,
            value_or_callback: Union[
                List[PatchModel],
                Callable[
                    [GenericListBuilder[PatchModel, PatchModel.Builder]],
                    GenericListBuilder[PatchModel, PatchModel.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(PatchModel.list_builder()).build()
            return self._set("patch", value)

        def target(
            self,
            value_or_callback: Union[Target, Callable[[Target.Builder], Target.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Target.builder()).build()
            return self._set("target", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["PatchesJson6902", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PatchesJson6902.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    patch: Annotated[
        List[PatchModel],
        Field(
            description="Patch contains the JSON6902 patch document with an array of operation objects."
        ),
    ]
    target: Annotated[
        Target,
        Field(
            description="Target points to the resources that the patch document should be applied to."
        ),
    ]


class SubstituteFrom(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["SubstituteFrom"]:
            return SubstituteFrom

        def build(self) -> "SubstituteFrom":
            return SubstituteFrom(**self._attrs)

        def kind(self, value: Literal["Secret", "ConfigMap"]) -> Self:
            return self._set("kind", value)

        def name(self, value: str) -> Self:
            return self._set("name", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["SubstituteFrom", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SubstituteFrom.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    kind: Annotated[
        Literal["Secret", "ConfigMap"],
        Field(description="Kind of the values referent, valid values are ('Secret', 'ConfigMap')."),
    ]
    name: Annotated[
        str,
        Field(
            description="Name of the values referent. Should reside in the same namespace as the\nreferring resource.",
            max_length=253,
            min_length=1,
        ),
    ]


class PostBuild(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["PostBuild"]:
            return PostBuild

        def build(self) -> "PostBuild":
            return PostBuild(**self._attrs)

        def substitute(self, value: Optional[Dict[str, str]]) -> Self:
            return self._set("substitute", value)

        def substitute_from(
            self,
            value_or_callback: Union[
                Optional[List[SubstituteFrom]],
                Callable[
                    [GenericListBuilder[SubstituteFrom, SubstituteFrom.Builder]],
                    GenericListBuilder[SubstituteFrom, SubstituteFrom.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SubstituteFrom.list_builder()).build()
            return self._set("substitute_from", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["PostBuild", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PostBuild.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    substitute: Annotated[
        Optional[Dict[str, str]],
        Field(
            description="Substitute holds a map of key/value pairs.\nThe variables defined in your YAML manifests\nthat match any of the keys defined in the map\nwill be substituted with the set value.\nIncludes support for bash string replacement functions\ne.g. ${var:=default}, ${var:position} and ${var/substring/replacement}."
        ),
    ] = None
    substitute_from: Annotated[
        Optional[List[SubstituteFrom]],
        Field(
            alias="substituteFrom",
            description="SubstituteFrom holds references to ConfigMaps and Secrets containing\nthe variables and their values to be substituted in the YAML manifests.\nThe ConfigMap and the Secret data keys represent the var names and they\nmust match the vars declared in the manifests for the substitution to happen.",
        ),
    ] = None


class SourceRef(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["SourceRef"]:
            return SourceRef

        def build(self) -> "SourceRef":
            return SourceRef(**self._attrs)

        def api_version(self, value: Optional[str]) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Literal["GitRepository", "Bucket"]) -> Self:
            return self._set("kind", value)

        def name(self, value: str) -> Self:
            return self._set("name", value)

        def namespace(self, value: Optional[str]) -> Self:
            return self._set("namespace", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["SourceRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SourceRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[str],
        Field(alias="apiVersion", description="API version of the referent"),
    ] = None
    kind: Annotated[Literal["GitRepository", "Bucket"], Field(description="Kind of the referent")]
    name: Annotated[str, Field(description="Name of the referent")]
    namespace: Annotated[
        Optional[str],
        Field(description="Namespace of the referent, defaults to the Kustomization namespace"),
    ] = None


class KustomizationSpec(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["KustomizationSpec"]:
            return KustomizationSpec

        def build(self) -> "KustomizationSpec":
            return KustomizationSpec(**self._attrs)

        def decryption(
            self,
            value_or_callback: Union[
                Optional[Decryption], Callable[[Decryption.Builder], Decryption.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Decryption.builder()).build()
            return self._set("decryption", value)

        def depends_on(
            self,
            value_or_callback: Union[
                Optional[List[DependsOn]],
                Callable[
                    [GenericListBuilder[DependsOn, DependsOn.Builder]],
                    GenericListBuilder[DependsOn, DependsOn.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(DependsOn.list_builder()).build()
            return self._set("depends_on", value)

        def force(self, value: Optional[bool]) -> Self:
            return self._set("force", value)

        def health_checks(
            self,
            value_or_callback: Union[
                Optional[List[HealthCheck]],
                Callable[
                    [GenericListBuilder[HealthCheck, HealthCheck.Builder]],
                    GenericListBuilder[HealthCheck, HealthCheck.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(HealthCheck.list_builder()).build()
            return self._set("health_checks", value)

        def images(
            self,
            value_or_callback: Union[
                Optional[List[Image]],
                Callable[
                    [GenericListBuilder[Image, Image.Builder]],
                    GenericListBuilder[Image, Image.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Image.list_builder()).build()
            return self._set("images", value)

        def interval(self, value: str) -> Self:
            return self._set("interval", value)

        def kube_config(
            self,
            value_or_callback: Union[
                Optional[KubeConfig], Callable[[KubeConfig.Builder], KubeConfig.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(KubeConfig.builder()).build()
            return self._set("kube_config", value)

        def patches(
            self,
            value_or_callback: Union[
                Optional[List[Patch]],
                Callable[
                    [GenericListBuilder[Patch, Patch.Builder]],
                    GenericListBuilder[Patch, Patch.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Patch.list_builder()).build()
            return self._set("patches", value)

        def patches_json6902(
            self,
            value_or_callback: Union[
                Optional[List[PatchesJson6902]],
                Callable[
                    [GenericListBuilder[PatchesJson6902, PatchesJson6902.Builder]],
                    GenericListBuilder[PatchesJson6902, PatchesJson6902.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(PatchesJson6902.list_builder()).build()
            return self._set("patches_json6902", value)

        def patches_strategic_merge(self, value: Optional[List[Any]]) -> Self:
            return self._set("patches_strategic_merge", value)

        def path(self, value: Optional[str]) -> Self:
            return self._set("path", value)

        def post_build(
            self,
            value_or_callback: Union[
                Optional[PostBuild], Callable[[PostBuild.Builder], PostBuild.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(PostBuild.builder()).build()
            return self._set("post_build", value)

        def prune(self, value: bool) -> Self:
            return self._set("prune", value)

        def retry_interval(self, value: Optional[str]) -> Self:
            return self._set("retry_interval", value)

        def service_account_name(self, value: Optional[str]) -> Self:
            return self._set("service_account_name", value)

        def source_ref(
            self,
            value_or_callback: Union[SourceRef, Callable[[SourceRef.Builder], SourceRef.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SourceRef.builder()).build()
            return self._set("source_ref", value)

        def suspend(self, value: Optional[bool]) -> Self:
            return self._set("suspend", value)

        def target_namespace(self, value: Optional[str]) -> Self:
            return self._set("target_namespace", value)

        def timeout(self, value: Optional[str]) -> Self:
            return self._set("timeout", value)

        def validation(self, value: Optional[Literal["none", "client", "server"]]) -> Self:
            return self._set("validation", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["KustomizationSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KustomizationSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    decryption: Annotated[
        Optional[Decryption],
        Field(description="Decrypt Kubernetes secrets before applying them on the cluster."),
    ] = None
    depends_on: Annotated[
        Optional[List[DependsOn]],
        Field(
            alias="dependsOn",
            description="DependsOn may contain a meta.NamespacedObjectReference slice\nwith references to Kustomization resources that must be ready before this\nKustomization can be reconciled.",
        ),
    ] = None
    force: Annotated[
        Optional[bool],
        Field(
            description="Force instructs the controller to recreate resources\nwhen patching fails due to an immutable field change."
        ),
    ] = False
    health_checks: Annotated[
        Optional[List[HealthCheck]],
        Field(
            alias="healthChecks",
            description="A list of resources to be included in the health assessment.",
        ),
    ] = None
    images: Annotated[
        Optional[List[Image]],
        Field(
            description="Images is a list of (image name, new name, new tag or digest)\nfor changing image names, tags or digests. This can also be achieved with a\npatch, but this operator is simpler to specify."
        ),
    ] = None
    interval: Annotated[
        str, Field(description="The interval at which to reconcile the Kustomization.")
    ]
    kube_config: Annotated[
        Optional[KubeConfig],
        Field(
            alias="kubeConfig",
            description="The KubeConfig for reconciling the Kustomization on a remote cluster.\nWhen specified, KubeConfig takes precedence over ServiceAccountName.",
        ),
    ] = None
    patches: Annotated[
        Optional[List[Patch]],
        Field(
            description="Strategic merge and JSON patches, defined as inline YAML objects,\ncapable of targeting objects based on kind, label and annotation selectors."
        ),
    ] = None
    patches_json6902: Annotated[
        Optional[List[PatchesJson6902]],
        Field(
            alias="patchesJson6902",
            description="JSON 6902 patches, defined as inline YAML objects.",
        ),
    ] = None
    patches_strategic_merge: Annotated[
        Optional[List[Any]],
        Field(
            alias="patchesStrategicMerge",
            description="Strategic merge patches, defined as inline YAML objects.",
        ),
    ] = None
    path: Annotated[
        Optional[str],
        Field(
            description="Path to the directory containing the kustomization.yaml file, or the\nset of plain YAMLs a kustomization.yaml should be generated for.\nDefaults to 'None', which translates to the root path of the SourceRef."
        ),
    ] = None
    post_build: Annotated[
        Optional[PostBuild],
        Field(
            alias="postBuild",
            description="PostBuild describes which actions to perform on the YAML manifest\ngenerated by building the kustomize overlay.",
        ),
    ] = None
    prune: Annotated[bool, Field(description="Prune enables garbage collection.")]
    retry_interval: Annotated[
        Optional[str],
        Field(
            alias="retryInterval",
            description="The interval at which to retry a previously failed reconciliation.\nWhen not specified, the controller uses the KustomizationSpec.Interval\nvalue to retry failures.",
        ),
    ] = None
    service_account_name: Annotated[
        Optional[str],
        Field(
            alias="serviceAccountName",
            description="The name of the Kubernetes service account to impersonate\nwhen reconciling this Kustomization.",
        ),
    ] = None
    source_ref: Annotated[
        SourceRef,
        Field(
            alias="sourceRef",
            description="Reference of the source where the kustomization file is.",
        ),
    ]
    suspend: Annotated[
        Optional[bool],
        Field(
            description="This flag tells the controller to suspend subsequent kustomize executions,\nit does not apply to already started executions. Defaults to false."
        ),
    ] = None
    target_namespace: Annotated[
        Optional[str],
        Field(
            alias="targetNamespace",
            description="TargetNamespace sets or overrides the namespace in the\nkustomization.yaml file.",
            max_length=63,
            min_length=1,
        ),
    ] = None
    timeout: Annotated[
        Optional[str],
        Field(
            description="Timeout for validation, apply and health checking operations.\nDefaults to 'Interval' duration."
        ),
    ] = None
    validation: Annotated[
        Optional[Literal["none", "client", "server"]],
        Field(
            description="Validate the Kubernetes objects before applying them on the cluster.\nThe validation strategy can be 'client' (local dry-run), 'server'\n(APIServer dry-run) or 'none'.\nWhen 'Force' is 'true', validation will fallback to 'client' if set to\n'server' because server-side validation is not supported in this scenario."
        ),
    ] = None


class Condition(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: datetime) -> Self:
            return self._set("last_transition_time", value)

        def message(self, value: str) -> Self:
            return self._set("message", value)

        def observed_generation(self, value: Optional[int]) -> Self:
            return self._set("observed_generation", value)

        def reason(self, value: str) -> Self:
            return self._set("reason", value)

        def status(self, value: Literal["True", "False", "Unknown"]) -> Self:
            return self._set("status", value)

        def type(self, value: str) -> Self:
            return self._set("type", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[
        datetime,
        Field(
            alias="lastTransitionTime",
            description="lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
        ),
    ]
    message: Annotated[
        str,
        Field(
            description="message is a human readable message indicating details about the transition.\nThis may be an empty string.",
            max_length=32768,
        ),
    ]
    observed_generation: Annotated[
        Optional[int],
        Field(
            alias="observedGeneration",
            description="observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
            ge=0,
        ),
    ] = None
    reason: Annotated[
        str,
        Field(
            description="reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.",
            max_length=1024,
            min_length=1,
            pattern="^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$",
        ),
    ]
    status: Annotated[
        Literal["True", "False", "Unknown"],
        Field(description="status of the condition, one of True, False, Unknown."),
    ]
    type: Annotated[
        str,
        Field(
            description="type of condition in CamelCase or in foo.example.com/CamelCase.",
            max_length=316,
            pattern="^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$",
        ),
    ]


class Entry(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Entry"]:
            return Entry

        def build(self) -> "Entry":
            return Entry(**self._attrs)

        def kinds(self, value: Dict[str, str]) -> Self:
            return self._set("kinds", value)

        def namespace(self, value: Optional[str]) -> Self:
            return self._set("namespace", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Entry", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Entry.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    kinds: Annotated[Dict[str, str], Field(description="The list of Kubernetes kinds.")]
    namespace: Annotated[Optional[str], Field(description="The namespace of this entry.")] = None


class Snapshot(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Snapshot"]:
            return Snapshot

        def build(self) -> "Snapshot":
            return Snapshot(**self._attrs)

        def checksum(self, value: str) -> Self:
            return self._set("checksum", value)

        def entries(
            self,
            value_or_callback: Union[
                List[Entry],
                Callable[
                    [GenericListBuilder[Entry, Entry.Builder]],
                    GenericListBuilder[Entry, Entry.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Entry.list_builder()).build()
            return self._set("entries", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Snapshot", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Snapshot.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    checksum: Annotated[str, Field(description="The manifests sha1 checksum.")]
    entries: Annotated[
        List[Entry],
        Field(description="A list of Kubernetes kinds grouped by namespace."),
    ]


class KustomizationStatus(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["KustomizationStatus"]:
            return KustomizationStatus

        def build(self) -> "KustomizationStatus":
            return KustomizationStatus(**self._attrs)

        def conditions(
            self,
            value_or_callback: Union[
                Optional[List[Condition]],
                Callable[
                    [GenericListBuilder[Condition, Condition.Builder]],
                    GenericListBuilder[Condition, Condition.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Condition.list_builder()).build()
            return self._set("conditions", value)

        def last_applied_revision(self, value: Optional[str]) -> Self:
            return self._set("last_applied_revision", value)

        def last_attempted_revision(self, value: Optional[str]) -> Self:
            return self._set("last_attempted_revision", value)

        def last_handled_reconcile_at(self, value: Optional[str]) -> Self:
            return self._set("last_handled_reconcile_at", value)

        def observed_generation(self, value: Optional[int]) -> Self:
            return self._set("observed_generation", value)

        def snapshot(
            self,
            value_or_callback: Union[
                Optional[Snapshot], Callable[[Snapshot.Builder], Snapshot.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Snapshot.builder()).build()
            return self._set("snapshot", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["KustomizationStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KustomizationStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    last_applied_revision: Annotated[
        Optional[str],
        Field(
            alias="lastAppliedRevision",
            description="The last successfully applied revision.\nThe revision format for Git sources is <branch|tag>/<commit-sha>.",
        ),
    ] = None
    last_attempted_revision: Annotated[
        Optional[str],
        Field(
            alias="lastAttemptedRevision",
            description="LastAttemptedRevision is the revision of the last reconciliation attempt.",
        ),
    ] = None
    last_handled_reconcile_at: Annotated[
        Optional[str],
        Field(
            alias="lastHandledReconcileAt",
            description="LastHandledReconcileAt holds the value of the most recent\nreconcile request value, so a change of the annotation value\ncan be detected.",
        ),
    ] = None
    observed_generation: Annotated[
        Optional[int],
        Field(
            alias="observedGeneration",
            description="ObservedGeneration is the last reconciled generation.",
        ),
    ] = None
    snapshot: Annotated[
        Optional[Snapshot],
        Field(description="The last successfully applied revision metadata."),
    ] = None


class Kustomization(Resource):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Kustomization"]:
            return Kustomization

        def build(self) -> "Kustomization":
            return Kustomization(**self._attrs)

        def api_version(
            self, value: Optional[Literal["kustomize.toolkit.fluxcd.io/v1beta1"]]
        ) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Kustomization"]]) -> Self:
            return self._set("kind", value)

        def metadata(
            self,
            value_or_callback: Union[
                Optional[apimachinery.ObjectMeta],
                Callable[[apimachinery.ObjectMeta.Builder], apimachinery.ObjectMeta.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(apimachinery.ObjectMeta.builder()).build()
            return self._set("metadata", value)

        def spec(
            self,
            value_or_callback: Union[
                Optional[KustomizationSpec],
                Callable[[KustomizationSpec.Builder], KustomizationSpec.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(KustomizationSpec.builder()).build()
            return self._set("spec", value)

        def status(
            self,
            value_or_callback: Union[
                Optional[KustomizationStatus],
                Callable[[KustomizationStatus.Builder], KustomizationStatus.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(KustomizationStatus.builder()).build()
            return self._set("status", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Kustomization", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Kustomization.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["kustomize.toolkit.fluxcd.io/v1beta1"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "kustomize.toolkit.fluxcd.io/v1beta1"
    kind: Annotated[
        Optional[Literal["Kustomization"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "Kustomization"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[KustomizationSpec] = None
    status: Optional[KustomizationStatus] = None
