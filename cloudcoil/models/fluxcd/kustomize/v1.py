# Generated by cloudcoil-model-codegen v0.2.1
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import Annotated, Callable, Dict, List, Literal, Optional, Type, Union

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import BaseBuilder, BaseModel, GenericListBuilder, Self
from cloudcoil.resources import Resource


class CommonMetadata(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["CommonMetadata"]:
            return CommonMetadata

        def build(self) -> "CommonMetadata":
            return CommonMetadata(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]]) -> Self:
            return self._set("annotations", value)

        def labels(self, value: Optional[Dict[str, str]]) -> Self:
            return self._set("labels", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["CommonMetadata", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CommonMetadata.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Annotated[
        Optional[Dict[str, str]],
        Field(description="Annotations to be added to the object's metadata."),
    ] = None
    labels: Annotated[
        Optional[Dict[str, str]],
        Field(description="Labels to be added to the object's metadata."),
    ] = None


class SecretRef(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["SecretRef"]:
            return SecretRef

        def build(self) -> "SecretRef":
            return SecretRef(**self._attrs)

        def name(self, value: str) -> Self:
            return self._set("name", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["SecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Annotated[str, Field(description="Name of the referent.")]


class Decryption(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Decryption"]:
            return Decryption

        def build(self) -> "Decryption":
            return Decryption(**self._attrs)

        def provider(self, value: Literal["sops"]) -> Self:
            return self._set("provider", value)

        def secret_ref(
            self,
            value_or_callback: Union[
                Optional[SecretRef], Callable[[SecretRef.Builder], SecretRef.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SecretRef.builder()).build()
            return self._set("secret_ref", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Decryption", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Decryption.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    provider: Annotated[
        Literal["sops"],
        Field(description="Provider is the name of the decryption engine."),
    ]
    secret_ref: Annotated[
        Optional[SecretRef],
        Field(
            alias="secretRef",
            description="The secret name containing the private OpenPGP keys used for decryption.",
        ),
    ] = None


class DependsOn(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["DependsOn"]:
            return DependsOn

        def build(self) -> "DependsOn":
            return DependsOn(**self._attrs)

        def name(self, value: str) -> Self:
            return self._set("name", value)

        def namespace(self, value: Optional[str]) -> Self:
            return self._set("namespace", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["DependsOn", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DependsOn.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Annotated[str, Field(description="Name of the referent.")]
    namespace: Annotated[
        Optional[str],
        Field(
            description="Namespace of the referent, when not specified it acts as LocalObjectReference."
        ),
    ] = None


class HealthCheck(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["HealthCheck"]:
            return HealthCheck

        def build(self) -> "HealthCheck":
            return HealthCheck(**self._attrs)

        def api_version(self, value: Optional[str]) -> Self:
            return self._set("api_version", value)

        def kind(self, value: str) -> Self:
            return self._set("kind", value)

        def name(self, value: str) -> Self:
            return self._set("name", value)

        def namespace(self, value: Optional[str]) -> Self:
            return self._set("namespace", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["HealthCheck", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HealthCheck.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[str],
        Field(
            alias="apiVersion",
            description="API version of the referent, if not specified the Kubernetes preferred version will be used.",
        ),
    ] = None
    kind: Annotated[str, Field(description="Kind of the referent.")]
    name: Annotated[str, Field(description="Name of the referent.")]
    namespace: Annotated[
        Optional[str],
        Field(
            description="Namespace of the referent, when not specified it acts as LocalObjectReference."
        ),
    ] = None


class Image(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Image"]:
            return Image

        def build(self) -> "Image":
            return Image(**self._attrs)

        def digest(self, value: Optional[str]) -> Self:
            return self._set("digest", value)

        def name(self, value: str) -> Self:
            return self._set("name", value)

        def new_name(self, value: Optional[str]) -> Self:
            return self._set("new_name", value)

        def new_tag(self, value: Optional[str]) -> Self:
            return self._set("new_tag", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Image", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Image.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    digest: Annotated[
        Optional[str],
        Field(
            description="Digest is the value used to replace the original image tag.\nIf digest is present NewTag value is ignored."
        ),
    ] = None
    name: Annotated[str, Field(description="Name is a tag-less image name.")]
    new_name: Annotated[
        Optional[str],
        Field(
            alias="newName",
            description="NewName is the value used to replace the original name.",
        ),
    ] = None
    new_tag: Annotated[
        Optional[str],
        Field(
            alias="newTag",
            description="NewTag is the value used to replace the original tag.",
        ),
    ] = None


class SecretRefModel(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["SecretRefModel"]:
            return SecretRefModel

        def build(self) -> "SecretRefModel":
            return SecretRefModel(**self._attrs)

        def key(self, value: Optional[str]) -> Self:
            return self._set("key", value)

        def name(self, value: str) -> Self:
            return self._set("name", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["SecretRefModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRefModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Annotated[
        Optional[str],
        Field(
            description="Key in the Secret, when not specified an implementation-specific default key is used."
        ),
    ] = None
    name: Annotated[str, Field(description="Name of the Secret.")]


class KubeConfig(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["KubeConfig"]:
            return KubeConfig

        def build(self) -> "KubeConfig":
            return KubeConfig(**self._attrs)

        def secret_ref(
            self,
            value_or_callback: Union[
                SecretRefModel,
                Callable[[SecretRefModel.Builder], SecretRefModel.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SecretRefModel.builder()).build()
            return self._set("secret_ref", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["KubeConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KubeConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secret_ref: Annotated[
        SecretRefModel,
        Field(
            alias="secretRef",
            description="SecretRef holds the name of a secret that contains a key with\nthe kubeconfig file as the value. If no key is set, the key will default\nto 'value'.\nIt is recommended that the kubeconfig is self-contained, and the secret\nis regularly updated if credentials such as a cloud-access-token expire.\nCloud specific `cmd-path` auth helpers will not function without adding\nbinaries and credentials to the Pod that is responsible for reconciling\nKubernetes resources.",
        ),
    ]


class Target(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Target"]:
            return Target

        def build(self) -> "Target":
            return Target(**self._attrs)

        def annotation_selector(self, value: Optional[str]) -> Self:
            return self._set("annotation_selector", value)

        def group(self, value: Optional[str]) -> Self:
            return self._set("group", value)

        def kind(self, value: Optional[str]) -> Self:
            return self._set("kind", value)

        def label_selector(self, value: Optional[str]) -> Self:
            return self._set("label_selector", value)

        def name(self, value: Optional[str]) -> Self:
            return self._set("name", value)

        def namespace(self, value: Optional[str]) -> Self:
            return self._set("namespace", value)

        def version(self, value: Optional[str]) -> Self:
            return self._set("version", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Target", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Target.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotation_selector: Annotated[
        Optional[str],
        Field(
            alias="annotationSelector",
            description="AnnotationSelector is a string that follows the label selection expression\nhttps://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api\nIt matches with the resource annotations.",
        ),
    ] = None
    group: Annotated[
        Optional[str],
        Field(
            description="Group is the API group to select resources from.\nTogether with Version and Kind it is capable of unambiguously identifying and/or selecting resources.\nhttps://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md"
        ),
    ] = None
    kind: Annotated[
        Optional[str],
        Field(
            description="Kind of the API Group to select resources from.\nTogether with Group and Version it is capable of unambiguously\nidentifying and/or selecting resources.\nhttps://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md"
        ),
    ] = None
    label_selector: Annotated[
        Optional[str],
        Field(
            alias="labelSelector",
            description="LabelSelector is a string that follows the label selection expression\nhttps://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api\nIt matches with the resource labels.",
        ),
    ] = None
    name: Annotated[Optional[str], Field(description="Name to match resources with.")] = None
    namespace: Annotated[
        Optional[str], Field(description="Namespace to select resources from.")
    ] = None
    version: Annotated[
        Optional[str],
        Field(
            description="Version of the API Group to select resources from.\nTogether with Group and Kind it is capable of unambiguously identifying and/or selecting resources.\nhttps://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md"
        ),
    ] = None


class Patch(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Patch"]:
            return Patch

        def build(self) -> "Patch":
            return Patch(**self._attrs)

        def patch(self, value: str) -> Self:
            return self._set("patch", value)

        def target(
            self,
            value_or_callback: Union[Optional[Target], Callable[[Target.Builder], Target.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Target.builder()).build()
            return self._set("target", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Patch", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Patch.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    patch: Annotated[
        str,
        Field(
            description="Patch contains an inline StrategicMerge patch or an inline JSON6902 patch with\nan array of operation objects."
        ),
    ]
    target: Annotated[
        Optional[Target],
        Field(
            description="Target points to the resources that the patch document should be applied to."
        ),
    ] = None


class SubstituteFrom(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["SubstituteFrom"]:
            return SubstituteFrom

        def build(self) -> "SubstituteFrom":
            return SubstituteFrom(**self._attrs)

        def kind(self, value: Literal["Secret", "ConfigMap"]) -> Self:
            return self._set("kind", value)

        def name(self, value: str) -> Self:
            return self._set("name", value)

        def optional(self, value: Optional[bool]) -> Self:
            return self._set("optional", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["SubstituteFrom", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SubstituteFrom.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    kind: Annotated[
        Literal["Secret", "ConfigMap"],
        Field(description="Kind of the values referent, valid values are ('Secret', 'ConfigMap')."),
    ]
    name: Annotated[
        str,
        Field(
            description="Name of the values referent. Should reside in the same namespace as the\nreferring resource.",
            max_length=253,
            min_length=1,
        ),
    ]
    optional: Annotated[
        Optional[bool],
        Field(
            description="Optional indicates whether the referenced resource must exist, or whether to\ntolerate its absence. If true and the referenced resource is absent, proceed\nas if the resource was present but empty, without any variables defined."
        ),
    ] = False


class PostBuild(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["PostBuild"]:
            return PostBuild

        def build(self) -> "PostBuild":
            return PostBuild(**self._attrs)

        def substitute(self, value: Optional[Dict[str, str]]) -> Self:
            return self._set("substitute", value)

        def substitute_from(
            self,
            value_or_callback: Union[
                Optional[List[SubstituteFrom]],
                Callable[
                    [GenericListBuilder[SubstituteFrom, SubstituteFrom.Builder]],
                    GenericListBuilder[SubstituteFrom, SubstituteFrom.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SubstituteFrom.list_builder()).build()
            return self._set("substitute_from", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["PostBuild", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PostBuild.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    substitute: Annotated[
        Optional[Dict[str, str]],
        Field(
            description="Substitute holds a map of key/value pairs.\nThe variables defined in your YAML manifests that match any of the keys\ndefined in the map will be substituted with the set value.\nIncludes support for bash string replacement functions\ne.g. ${var:=default}, ${var:position} and ${var/substring/replacement}."
        ),
    ] = None
    substitute_from: Annotated[
        Optional[List[SubstituteFrom]],
        Field(
            alias="substituteFrom",
            description="SubstituteFrom holds references to ConfigMaps and Secrets containing\nthe variables and their values to be substituted in the YAML manifests.\nThe ConfigMap and the Secret data keys represent the var names, and they\nmust match the vars declared in the manifests for the substitution to\nhappen.",
        ),
    ] = None


class SourceRef(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["SourceRef"]:
            return SourceRef

        def build(self) -> "SourceRef":
            return SourceRef(**self._attrs)

        def api_version(self, value: Optional[str]) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Literal["OCIRepository", "GitRepository", "Bucket"]) -> Self:
            return self._set("kind", value)

        def name(self, value: str) -> Self:
            return self._set("name", value)

        def namespace(self, value: Optional[str]) -> Self:
            return self._set("namespace", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["SourceRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SourceRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[str],
        Field(alias="apiVersion", description="API version of the referent."),
    ] = None
    kind: Annotated[
        Literal["OCIRepository", "GitRepository", "Bucket"],
        Field(description="Kind of the referent."),
    ]
    name: Annotated[str, Field(description="Name of the referent.")]
    namespace: Annotated[
        Optional[str],
        Field(
            description="Namespace of the referent, defaults to the namespace of the Kubernetes\nresource object that contains the reference."
        ),
    ] = None


class KustomizationSpec(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["KustomizationSpec"]:
            return KustomizationSpec

        def build(self) -> "KustomizationSpec":
            return KustomizationSpec(**self._attrs)

        def common_metadata(
            self,
            value_or_callback: Union[
                Optional[CommonMetadata],
                Callable[[CommonMetadata.Builder], CommonMetadata.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(CommonMetadata.builder()).build()
            return self._set("common_metadata", value)

        def components(self, value: Optional[List[str]]) -> Self:
            return self._set("components", value)

        def decryption(
            self,
            value_or_callback: Union[
                Optional[Decryption], Callable[[Decryption.Builder], Decryption.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Decryption.builder()).build()
            return self._set("decryption", value)

        def depends_on(
            self,
            value_or_callback: Union[
                Optional[List[DependsOn]],
                Callable[
                    [GenericListBuilder[DependsOn, DependsOn.Builder]],
                    GenericListBuilder[DependsOn, DependsOn.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(DependsOn.list_builder()).build()
            return self._set("depends_on", value)

        def force(self, value: Optional[bool]) -> Self:
            return self._set("force", value)

        def health_checks(
            self,
            value_or_callback: Union[
                Optional[List[HealthCheck]],
                Callable[
                    [GenericListBuilder[HealthCheck, HealthCheck.Builder]],
                    GenericListBuilder[HealthCheck, HealthCheck.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(HealthCheck.list_builder()).build()
            return self._set("health_checks", value)

        def images(
            self,
            value_or_callback: Union[
                Optional[List[Image]],
                Callable[
                    [GenericListBuilder[Image, Image.Builder]],
                    GenericListBuilder[Image, Image.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Image.list_builder()).build()
            return self._set("images", value)

        def interval(self, value: str) -> Self:
            return self._set("interval", value)

        def kube_config(
            self,
            value_or_callback: Union[
                Optional[KubeConfig], Callable[[KubeConfig.Builder], KubeConfig.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(KubeConfig.builder()).build()
            return self._set("kube_config", value)

        def name_prefix(self, value: Optional[str]) -> Self:
            return self._set("name_prefix", value)

        def name_suffix(self, value: Optional[str]) -> Self:
            return self._set("name_suffix", value)

        def patches(
            self,
            value_or_callback: Union[
                Optional[List[Patch]],
                Callable[
                    [GenericListBuilder[Patch, Patch.Builder]],
                    GenericListBuilder[Patch, Patch.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Patch.list_builder()).build()
            return self._set("patches", value)

        def path(self, value: Optional[str]) -> Self:
            return self._set("path", value)

        def post_build(
            self,
            value_or_callback: Union[
                Optional[PostBuild], Callable[[PostBuild.Builder], PostBuild.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(PostBuild.builder()).build()
            return self._set("post_build", value)

        def prune(self, value: bool) -> Self:
            return self._set("prune", value)

        def retry_interval(self, value: Optional[str]) -> Self:
            return self._set("retry_interval", value)

        def service_account_name(self, value: Optional[str]) -> Self:
            return self._set("service_account_name", value)

        def source_ref(
            self,
            value_or_callback: Union[SourceRef, Callable[[SourceRef.Builder], SourceRef.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SourceRef.builder()).build()
            return self._set("source_ref", value)

        def suspend(self, value: Optional[bool]) -> Self:
            return self._set("suspend", value)

        def target_namespace(self, value: Optional[str]) -> Self:
            return self._set("target_namespace", value)

        def timeout(self, value: Optional[str]) -> Self:
            return self._set("timeout", value)

        def wait(self, value: Optional[bool]) -> Self:
            return self._set("wait", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["KustomizationSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KustomizationSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    common_metadata: Annotated[
        Optional[CommonMetadata],
        Field(
            alias="commonMetadata",
            description="CommonMetadata specifies the common labels and annotations that are\napplied to all resources. Any existing label or annotation will be\noverridden if its key matches a common one.",
        ),
    ] = None
    components: Annotated[
        Optional[List[str]],
        Field(
            description="Components specifies relative paths to specifications of other Components."
        ),
    ] = None
    decryption: Annotated[
        Optional[Decryption],
        Field(description="Decrypt Kubernetes secrets before applying them on the cluster."),
    ] = None
    depends_on: Annotated[
        Optional[List[DependsOn]],
        Field(
            alias="dependsOn",
            description="DependsOn may contain a meta.NamespacedObjectReference slice\nwith references to Kustomization resources that must be ready before this\nKustomization can be reconciled.",
        ),
    ] = None
    force: Annotated[
        Optional[bool],
        Field(
            description="Force instructs the controller to recreate resources\nwhen patching fails due to an immutable field change."
        ),
    ] = False
    health_checks: Annotated[
        Optional[List[HealthCheck]],
        Field(
            alias="healthChecks",
            description="A list of resources to be included in the health assessment.",
        ),
    ] = None
    images: Annotated[
        Optional[List[Image]],
        Field(
            description="Images is a list of (image name, new name, new tag or digest)\nfor changing image names, tags or digests. This can also be achieved with a\npatch, but this operator is simpler to specify."
        ),
    ] = None
    interval: Annotated[
        str,
        Field(
            description="The interval at which to reconcile the Kustomization.\nThis interval is approximate and may be subject to jitter to ensure\nefficient use of resources.",
            pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$",
        ),
    ]
    kube_config: Annotated[
        Optional[KubeConfig],
        Field(
            alias="kubeConfig",
            description="The KubeConfig for reconciling the Kustomization on a remote cluster.\nWhen used in combination with KustomizationSpec.ServiceAccountName,\nforces the controller to act on behalf of that Service Account at the\ntarget cluster.\nIf the --default-service-account flag is set, its value will be used as\na controller level fallback for when KustomizationSpec.ServiceAccountName\nis empty.",
        ),
    ] = None
    name_prefix: Annotated[
        Optional[str],
        Field(
            alias="namePrefix",
            description="NamePrefix will prefix the names of all managed resources.",
            max_length=200,
            min_length=1,
        ),
    ] = None
    name_suffix: Annotated[
        Optional[str],
        Field(
            alias="nameSuffix",
            description="NameSuffix will suffix the names of all managed resources.",
            max_length=200,
            min_length=1,
        ),
    ] = None
    patches: Annotated[
        Optional[List[Patch]],
        Field(
            description="Strategic merge and JSON patches, defined as inline YAML objects,\ncapable of targeting objects based on kind, label and annotation selectors."
        ),
    ] = None
    path: Annotated[
        Optional[str],
        Field(
            description="Path to the directory containing the kustomization.yaml file, or the\nset of plain YAMLs a kustomization.yaml should be generated for.\nDefaults to 'None', which translates to the root path of the SourceRef."
        ),
    ] = None
    post_build: Annotated[
        Optional[PostBuild],
        Field(
            alias="postBuild",
            description="PostBuild describes which actions to perform on the YAML manifest\ngenerated by building the kustomize overlay.",
        ),
    ] = None
    prune: Annotated[bool, Field(description="Prune enables garbage collection.")]
    retry_interval: Annotated[
        Optional[str],
        Field(
            alias="retryInterval",
            description="The interval at which to retry a previously failed reconciliation.\nWhen not specified, the controller uses the KustomizationSpec.Interval\nvalue to retry failures.",
            pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$",
        ),
    ] = None
    service_account_name: Annotated[
        Optional[str],
        Field(
            alias="serviceAccountName",
            description="The name of the Kubernetes service account to impersonate\nwhen reconciling this Kustomization.",
        ),
    ] = None
    source_ref: Annotated[
        SourceRef,
        Field(
            alias="sourceRef",
            description="Reference of the source where the kustomization file is.",
        ),
    ]
    suspend: Annotated[
        Optional[bool],
        Field(
            description="This flag tells the controller to suspend subsequent kustomize executions,\nit does not apply to already started executions. Defaults to false."
        ),
    ] = None
    target_namespace: Annotated[
        Optional[str],
        Field(
            alias="targetNamespace",
            description="TargetNamespace sets or overrides the namespace in the\nkustomization.yaml file.",
            max_length=63,
            min_length=1,
        ),
    ] = None
    timeout: Annotated[
        Optional[str],
        Field(
            description="Timeout for validation, apply and health checking operations.\nDefaults to 'Interval' duration.",
            pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$",
        ),
    ] = None
    wait: Annotated[
        Optional[bool],
        Field(
            description="Wait instructs the controller to check the health of all the reconciled\nresources. When enabled, the HealthChecks are ignored. Defaults to false."
        ),
    ] = None


class Condition(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: datetime) -> Self:
            return self._set("last_transition_time", value)

        def message(self, value: str) -> Self:
            return self._set("message", value)

        def observed_generation(self, value: Optional[int]) -> Self:
            return self._set("observed_generation", value)

        def reason(self, value: str) -> Self:
            return self._set("reason", value)

        def status(self, value: Literal["True", "False", "Unknown"]) -> Self:
            return self._set("status", value)

        def type(self, value: str) -> Self:
            return self._set("type", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[
        datetime,
        Field(
            alias="lastTransitionTime",
            description="lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
        ),
    ]
    message: Annotated[
        str,
        Field(
            description="message is a human readable message indicating details about the transition.\nThis may be an empty string.",
            max_length=32768,
        ),
    ]
    observed_generation: Annotated[
        Optional[int],
        Field(
            alias="observedGeneration",
            description="observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
            ge=0,
        ),
    ] = None
    reason: Annotated[
        str,
        Field(
            description="reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.",
            max_length=1024,
            min_length=1,
            pattern="^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$",
        ),
    ]
    status: Annotated[
        Literal["True", "False", "Unknown"],
        Field(description="status of the condition, one of True, False, Unknown."),
    ]
    type: Annotated[
        str,
        Field(
            description="type of condition in CamelCase or in foo.example.com/CamelCase.",
            max_length=316,
            pattern="^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$",
        ),
    ]


class Entry(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Entry"]:
            return Entry

        def build(self) -> "Entry":
            return Entry(**self._attrs)

        def id(self, value: str) -> Self:
            return self._set("id", value)

        def v(self, value: str) -> Self:
            return self._set("v", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Entry", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Entry.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    id: Annotated[
        str,
        Field(
            description="ID is the string representation of the Kubernetes resource object's metadata,\nin the format '<namespace>_<name>_<group>_<kind>'."
        ),
    ]
    v: Annotated[
        str,
        Field(description="Version is the API version of the Kubernetes resource object's kind."),
    ]


class Inventory(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Inventory"]:
            return Inventory

        def build(self) -> "Inventory":
            return Inventory(**self._attrs)

        def entries(
            self,
            value_or_callback: Union[
                List[Entry],
                Callable[
                    [GenericListBuilder[Entry, Entry.Builder]],
                    GenericListBuilder[Entry, Entry.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Entry.list_builder()).build()
            return self._set("entries", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Inventory", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Inventory.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    entries: Annotated[
        List[Entry],
        Field(description="Entries of Kubernetes resource object references."),
    ]


class KustomizationStatus(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["KustomizationStatus"]:
            return KustomizationStatus

        def build(self) -> "KustomizationStatus":
            return KustomizationStatus(**self._attrs)

        def conditions(
            self,
            value_or_callback: Union[
                Optional[List[Condition]],
                Callable[
                    [GenericListBuilder[Condition, Condition.Builder]],
                    GenericListBuilder[Condition, Condition.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Condition.list_builder()).build()
            return self._set("conditions", value)

        def inventory(
            self,
            value_or_callback: Union[
                Optional[Inventory], Callable[[Inventory.Builder], Inventory.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Inventory.builder()).build()
            return self._set("inventory", value)

        def last_applied_revision(self, value: Optional[str]) -> Self:
            return self._set("last_applied_revision", value)

        def last_attempted_revision(self, value: Optional[str]) -> Self:
            return self._set("last_attempted_revision", value)

        def last_handled_reconcile_at(self, value: Optional[str]) -> Self:
            return self._set("last_handled_reconcile_at", value)

        def observed_generation(self, value: Optional[int]) -> Self:
            return self._set("observed_generation", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["KustomizationStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KustomizationStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    inventory: Annotated[
        Optional[Inventory],
        Field(
            description="Inventory contains the list of Kubernetes resource object references that\nhave been successfully applied."
        ),
    ] = None
    last_applied_revision: Annotated[
        Optional[str],
        Field(
            alias="lastAppliedRevision",
            description="The last successfully applied revision.\nEquals the Revision of the applied Artifact from the referenced Source.",
        ),
    ] = None
    last_attempted_revision: Annotated[
        Optional[str],
        Field(
            alias="lastAttemptedRevision",
            description="LastAttemptedRevision is the revision of the last reconciliation attempt.",
        ),
    ] = None
    last_handled_reconcile_at: Annotated[
        Optional[str],
        Field(
            alias="lastHandledReconcileAt",
            description="LastHandledReconcileAt holds the value of the most recent\nreconcile request value, so a change of the annotation value\ncan be detected.",
        ),
    ] = None
    observed_generation: Annotated[
        Optional[int],
        Field(
            alias="observedGeneration",
            description="ObservedGeneration is the last reconciled generation.",
        ),
    ] = None


class Kustomization(Resource):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Kustomization"]:
            return Kustomization

        def build(self) -> "Kustomization":
            return Kustomization(**self._attrs)

        def api_version(self, value: Optional[Literal["kustomize.toolkit.fluxcd.io/v1"]]) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Kustomization"]]) -> Self:
            return self._set("kind", value)

        def metadata(
            self,
            value_or_callback: Union[
                Optional[apimachinery.ObjectMeta],
                Callable[[apimachinery.ObjectMeta.Builder], apimachinery.ObjectMeta.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(apimachinery.ObjectMeta.builder()).build()
            return self._set("metadata", value)

        def spec(
            self,
            value_or_callback: Union[
                Optional[KustomizationSpec],
                Callable[[KustomizationSpec.Builder], KustomizationSpec.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(KustomizationSpec.builder()).build()
            return self._set("spec", value)

        def status(
            self,
            value_or_callback: Union[
                Optional[KustomizationStatus],
                Callable[[KustomizationStatus.Builder], KustomizationStatus.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(KustomizationStatus.builder()).build()
            return self._set("status", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Kustomization", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Kustomization.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["kustomize.toolkit.fluxcd.io/v1"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "kustomize.toolkit.fluxcd.io/v1"
    kind: Annotated[
        Optional[Literal["Kustomization"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "Kustomization"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[KustomizationSpec] = None
    status: Optional[KustomizationStatus] = None
