# Generated by cloudcoil-model-codegen v0.2.1
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import Annotated, Callable, Dict, List, Literal, Optional, Type, Union

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import BaseBuilder, BaseModel, GenericListBuilder, Self
from cloudcoil.resources import Resource


class NamespaceSelector(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["NamespaceSelector"]:
            return NamespaceSelector

        def build(self) -> "NamespaceSelector":
            return NamespaceSelector(**self._attrs)

        def match_labels(self, value: Optional[Dict[str, str]]) -> Self:
            return self._set("match_labels", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["NamespaceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamespaceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_labels: Annotated[
        Optional[Dict[str, str]],
        Field(
            alias="matchLabels",
            description='MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is "key", the\noperator is "In", and the values array contains only "value". The requirements are ANDed.',
        ),
    ] = None


class AccessFrom(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["AccessFrom"]:
            return AccessFrom

        def build(self) -> "AccessFrom":
            return AccessFrom(**self._attrs)

        def namespace_selectors(
            self,
            value_or_callback: Union[
                List[NamespaceSelector],
                Callable[
                    [GenericListBuilder[NamespaceSelector, NamespaceSelector.Builder]],
                    GenericListBuilder[NamespaceSelector, NamespaceSelector.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(NamespaceSelector.list_builder()).build()
            return self._set("namespace_selectors", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["AccessFrom", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AccessFrom.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    namespace_selectors: Annotated[
        List[NamespaceSelector],
        Field(
            alias="namespaceSelectors",
            description="NamespaceSelectors is the list of namespace selectors to which this ACL applies.\nItems in this list are evaluated using a logical OR operation.",
        ),
    ]


class CertSecretRef(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["CertSecretRef"]:
            return CertSecretRef

        def build(self) -> "CertSecretRef":
            return CertSecretRef(**self._attrs)

        def name(self, value: str) -> Self:
            return self._set("name", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["CertSecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CertSecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Annotated[str, Field(description="Name of the referent.")]


class ProxySecretRef(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["ProxySecretRef"]:
            return ProxySecretRef

        def build(self) -> "ProxySecretRef":
            return ProxySecretRef(**self._attrs)

        def name(self, value: str) -> Self:
            return self._set("name", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["ProxySecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProxySecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Annotated[str, Field(description="Name of the referent.")]


class SecretRef(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["SecretRef"]:
            return SecretRef

        def build(self) -> "SecretRef":
            return SecretRef(**self._attrs)

        def name(self, value: str) -> Self:
            return self._set("name", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["SecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Annotated[str, Field(description="Name of the referent.")]


class Sts(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Sts"]:
            return Sts

        def build(self) -> "Sts":
            return Sts(**self._attrs)

        def cert_secret_ref(
            self,
            value_or_callback: Union[
                Optional[CertSecretRef],
                Callable[[CertSecretRef.Builder], CertSecretRef.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(CertSecretRef.builder()).build()
            return self._set("cert_secret_ref", value)

        def endpoint(self, value: str) -> Self:
            return self._set("endpoint", value)

        def provider(self, value: Literal["aws", "ldap"]) -> Self:
            return self._set("provider", value)

        def secret_ref(
            self,
            value_or_callback: Union[
                Optional[SecretRef], Callable[[SecretRef.Builder], SecretRef.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SecretRef.builder()).build()
            return self._set("secret_ref", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Sts", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Sts.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cert_secret_ref: Annotated[
        Optional[CertSecretRef],
        Field(
            alias="certSecretRef",
            description="CertSecretRef can be given the name of a Secret containing\neither or both of\n\n- a PEM-encoded client certificate (`tls.crt`) and private\nkey (`tls.key`);\n- a PEM-encoded CA certificate (`ca.crt`)\n\nand whichever are supplied, will be used for connecting to the\nSTS endpoint. The client cert and key are useful if you are\nauthenticating with a certificate; the CA cert is useful if\nyou are using a self-signed server certificate. The Secret must\nbe of type `Opaque` or `kubernetes.io/tls`.\n\nThis field is only supported for the `ldap` provider.",
        ),
    ] = None
    endpoint: Annotated[
        str,
        Field(
            description="Endpoint is the HTTP/S endpoint of the Security Token Service from\nwhere temporary credentials will be fetched.",
            pattern="^(http|https)://.*$",
        ),
    ]
    provider: Annotated[
        Literal["aws", "ldap"],
        Field(description="Provider of the Security Token Service."),
    ]
    secret_ref: Annotated[
        Optional[SecretRef],
        Field(
            alias="secretRef",
            description="SecretRef specifies the Secret containing authentication credentials\nfor the STS endpoint. This Secret must contain the fields `username`\nand `password` and is supported only for the `ldap` provider.",
        ),
    ] = None


class BucketSpec(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["BucketSpec"]:
            return BucketSpec

        def build(self) -> "BucketSpec":
            return BucketSpec(**self._attrs)

        def access_from(
            self,
            value_or_callback: Union[
                Optional[AccessFrom], Callable[[AccessFrom.Builder], AccessFrom.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(AccessFrom.builder()).build()
            return self._set("access_from", value)

        def bucket_name(self, value: str) -> Self:
            return self._set("bucket_name", value)

        def cert_secret_ref(
            self,
            value_or_callback: Union[
                Optional[CertSecretRef],
                Callable[[CertSecretRef.Builder], CertSecretRef.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(CertSecretRef.builder()).build()
            return self._set("cert_secret_ref", value)

        def endpoint(self, value: str) -> Self:
            return self._set("endpoint", value)

        def ignore(self, value: Optional[str]) -> Self:
            return self._set("ignore", value)

        def insecure(self, value: Optional[bool]) -> Self:
            return self._set("insecure", value)

        def interval(self, value: str) -> Self:
            return self._set("interval", value)

        def prefix(self, value: Optional[str]) -> Self:
            return self._set("prefix", value)

        def provider(self, value: Optional[Literal["generic", "aws", "gcp", "azure"]]) -> Self:
            return self._set("provider", value)

        def proxy_secret_ref(
            self,
            value_or_callback: Union[
                Optional[ProxySecretRef],
                Callable[[ProxySecretRef.Builder], ProxySecretRef.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(ProxySecretRef.builder()).build()
            return self._set("proxy_secret_ref", value)

        def region(self, value: Optional[str]) -> Self:
            return self._set("region", value)

        def secret_ref(
            self,
            value_or_callback: Union[
                Optional[SecretRef], Callable[[SecretRef.Builder], SecretRef.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SecretRef.builder()).build()
            return self._set("secret_ref", value)

        def sts(
            self,
            value_or_callback: Union[Optional[Sts], Callable[[Sts.Builder], Sts.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Sts.builder()).build()
            return self._set("sts", value)

        def suspend(self, value: Optional[bool]) -> Self:
            return self._set("suspend", value)

        def timeout(self, value: Optional[str]) -> Self:
            return self._set("timeout", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["BucketSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BucketSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_from: Annotated[
        Optional[AccessFrom],
        Field(
            alias="accessFrom",
            description="AccessFrom specifies an Access Control List for allowing cross-namespace\nreferences to this object.\nNOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092",
        ),
    ] = None
    bucket_name: Annotated[
        str,
        Field(
            alias="bucketName",
            description="BucketName is the name of the object storage bucket.",
        ),
    ]
    cert_secret_ref: Annotated[
        Optional[CertSecretRef],
        Field(
            alias="certSecretRef",
            description="CertSecretRef can be given the name of a Secret containing\neither or both of\n\n- a PEM-encoded client certificate (`tls.crt`) and private\nkey (`tls.key`);\n- a PEM-encoded CA certificate (`ca.crt`)\n\nand whichever are supplied, will be used for connecting to the\nbucket. The client cert and key are useful if you are\nauthenticating with a certificate; the CA cert is useful if\nyou are using a self-signed server certificate. The Secret must\nbe of type `Opaque` or `kubernetes.io/tls`.\n\nThis field is only supported for the `generic` provider.",
        ),
    ] = None
    endpoint: Annotated[
        str,
        Field(description="Endpoint is the object storage address the BucketName is located at."),
    ]
    ignore: Annotated[
        Optional[str],
        Field(
            description="Ignore overrides the set of excluded patterns in the .sourceignore format\n(which is the same as .gitignore). If not provided, a default will be used,\nconsult the documentation for your version to find out what those are."
        ),
    ] = None
    insecure: Annotated[
        Optional[bool],
        Field(description="Insecure allows connecting to a non-TLS HTTP Endpoint."),
    ] = None
    interval: Annotated[
        str,
        Field(
            description="Interval at which the Bucket Endpoint is checked for updates.\nThis interval is approximate and may be subject to jitter to ensure\nefficient use of resources.",
            pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$",
        ),
    ]
    prefix: Annotated[
        Optional[str],
        Field(description="Prefix to use for server-side filtering of files in the Bucket."),
    ] = None
    provider: Annotated[
        Optional[Literal["generic", "aws", "gcp", "azure"]],
        Field(
            description="Provider of the object storage bucket.\nDefaults to 'generic', which expects an S3 (API) compatible object\nstorage."
        ),
    ] = "generic"
    proxy_secret_ref: Annotated[
        Optional[ProxySecretRef],
        Field(
            alias="proxySecretRef",
            description="ProxySecretRef specifies the Secret containing the proxy configuration\nto use while communicating with the Bucket server.",
        ),
    ] = None
    region: Annotated[
        Optional[str],
        Field(description="Region of the Endpoint where the BucketName is located in."),
    ] = None
    secret_ref: Annotated[
        Optional[SecretRef],
        Field(
            alias="secretRef",
            description="SecretRef specifies the Secret containing authentication credentials\nfor the Bucket.",
        ),
    ] = None
    sts: Annotated[
        Optional[Sts],
        Field(
            description="STS specifies the required configuration to use a Security Token\nService for fetching temporary credentials to authenticate in a\nBucket provider.\n\nThis field is only supported for the `aws` and `generic` providers."
        ),
    ] = None
    suspend: Annotated[
        Optional[bool],
        Field(
            description="Suspend tells the controller to suspend the reconciliation of this\nBucket."
        ),
    ] = None
    timeout: Annotated[
        Optional[str],
        Field(
            description="Timeout for fetch operations, defaults to 60s.",
            pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m))+$",
        ),
    ] = "60s"


class Artifact(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Artifact"]:
            return Artifact

        def build(self) -> "Artifact":
            return Artifact(**self._attrs)

        def digest(self, value: Optional[str]) -> Self:
            return self._set("digest", value)

        def last_update_time(self, value: datetime) -> Self:
            return self._set("last_update_time", value)

        def metadata(self, value: Optional[Dict[str, str]]) -> Self:
            return self._set("metadata", value)

        def path(self, value: str) -> Self:
            return self._set("path", value)

        def revision(self, value: str) -> Self:
            return self._set("revision", value)

        def size(self, value: Optional[int]) -> Self:
            return self._set("size", value)

        def url(self, value: str) -> Self:
            return self._set("url", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Artifact", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Artifact.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    digest: Annotated[
        Optional[str],
        Field(
            description="Digest is the digest of the file in the form of '<algorithm>:<checksum>'.",
            pattern="^[a-z0-9]+(?:[.+_-][a-z0-9]+)*:[a-zA-Z0-9=_-]+$",
        ),
    ] = None
    last_update_time: Annotated[
        datetime,
        Field(
            alias="lastUpdateTime",
            description="LastUpdateTime is the timestamp corresponding to the last update of the\nArtifact.",
        ),
    ]
    metadata: Annotated[
        Optional[Dict[str, str]],
        Field(description="Metadata holds upstream information such as OCI annotations."),
    ] = None
    path: Annotated[
        str,
        Field(
            description="Path is the relative file path of the Artifact. It can be used to locate\nthe file in the root of the Artifact storage on the local file system of\nthe controller managing the Source."
        ),
    ]
    revision: Annotated[
        str,
        Field(
            description="Revision is a human-readable identifier traceable in the origin source\nsystem. It can be a Git commit SHA, Git tag, a Helm chart version, etc."
        ),
    ]
    size: Annotated[
        Optional[int], Field(description="Size is the number of bytes in the file.")
    ] = None
    url: Annotated[
        str,
        Field(
            description="URL is the HTTP address of the Artifact as exposed by the controller\nmanaging the Source. It can be used to retrieve the Artifact for\nconsumption, e.g. by another controller applying the Artifact contents."
        ),
    ]


class Condition(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: datetime) -> Self:
            return self._set("last_transition_time", value)

        def message(self, value: str) -> Self:
            return self._set("message", value)

        def observed_generation(self, value: Optional[int]) -> Self:
            return self._set("observed_generation", value)

        def reason(self, value: str) -> Self:
            return self._set("reason", value)

        def status(self, value: Literal["True", "False", "Unknown"]) -> Self:
            return self._set("status", value)

        def type(self, value: str) -> Self:
            return self._set("type", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[
        datetime,
        Field(
            alias="lastTransitionTime",
            description="lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
        ),
    ]
    message: Annotated[
        str,
        Field(
            description="message is a human readable message indicating details about the transition.\nThis may be an empty string.",
            max_length=32768,
        ),
    ]
    observed_generation: Annotated[
        Optional[int],
        Field(
            alias="observedGeneration",
            description="observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
            ge=0,
        ),
    ] = None
    reason: Annotated[
        str,
        Field(
            description="reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.",
            max_length=1024,
            min_length=1,
            pattern="^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$",
        ),
    ]
    status: Annotated[
        Literal["True", "False", "Unknown"],
        Field(description="status of the condition, one of True, False, Unknown."),
    ]
    type: Annotated[
        str,
        Field(
            description="type of condition in CamelCase or in foo.example.com/CamelCase.",
            max_length=316,
            pattern="^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$",
        ),
    ]


class BucketStatus(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["BucketStatus"]:
            return BucketStatus

        def build(self) -> "BucketStatus":
            return BucketStatus(**self._attrs)

        def artifact(
            self,
            value_or_callback: Union[
                Optional[Artifact], Callable[[Artifact.Builder], Artifact.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Artifact.builder()).build()
            return self._set("artifact", value)

        def conditions(
            self,
            value_or_callback: Union[
                Optional[List[Condition]],
                Callable[
                    [GenericListBuilder[Condition, Condition.Builder]],
                    GenericListBuilder[Condition, Condition.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Condition.list_builder()).build()
            return self._set("conditions", value)

        def last_handled_reconcile_at(self, value: Optional[str]) -> Self:
            return self._set("last_handled_reconcile_at", value)

        def observed_generation(self, value: Optional[int]) -> Self:
            return self._set("observed_generation", value)

        def observed_ignore(self, value: Optional[str]) -> Self:
            return self._set("observed_ignore", value)

        def url(self, value: Optional[str]) -> Self:
            return self._set("url", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["BucketStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BucketStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    artifact: Annotated[
        Optional[Artifact],
        Field(description="Artifact represents the last successful Bucket reconciliation."),
    ] = None
    conditions: Annotated[
        Optional[List[Condition]],
        Field(description="Conditions holds the conditions for the Bucket."),
    ] = None
    last_handled_reconcile_at: Annotated[
        Optional[str],
        Field(
            alias="lastHandledReconcileAt",
            description="LastHandledReconcileAt holds the value of the most recent\nreconcile request value, so a change of the annotation value\ncan be detected.",
        ),
    ] = None
    observed_generation: Annotated[
        Optional[int],
        Field(
            alias="observedGeneration",
            description="ObservedGeneration is the last observed generation of the Bucket object.",
        ),
    ] = None
    observed_ignore: Annotated[
        Optional[str],
        Field(
            alias="observedIgnore",
            description="ObservedIgnore is the observed exclusion patterns used for constructing\nthe source artifact.",
        ),
    ] = None
    url: Annotated[
        Optional[str],
        Field(
            description='URL is the dynamic fetch link for the latest Artifact.\nIt is provided on a "best effort" basis, and using the precise\nBucketStatus.Artifact data is recommended.'
        ),
    ] = None


class Repository(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Repository"]:
            return Repository

        def build(self) -> "Repository":
            return Repository(**self._attrs)

        def name(self, value: str) -> Self:
            return self._set("name", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Repository", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Repository.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Annotated[str, Field(description="Name of the referent.")]


class Include(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Include"]:
            return Include

        def build(self) -> "Include":
            return Include(**self._attrs)

        def from_path(self, value: Optional[str]) -> Self:
            return self._set("from_path", value)

        def repository(
            self,
            value_or_callback: Union[
                Repository, Callable[[Repository.Builder], Repository.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Repository.builder()).build()
            return self._set("repository", value)

        def to_path(self, value: Optional[str]) -> Self:
            return self._set("to_path", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Include", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Include.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    from_path: Annotated[
        Optional[str],
        Field(
            alias="fromPath",
            description="FromPath specifies the path to copy contents from, defaults to the root\nof the Artifact.",
        ),
    ] = None
    repository: Annotated[
        Repository,
        Field(
            description="GitRepositoryRef specifies the GitRepository which Artifact contents\nmust be included."
        ),
    ]
    to_path: Annotated[
        Optional[str],
        Field(
            alias="toPath",
            description="ToPath specifies the path to copy contents to, defaults to the name of\nthe GitRepositoryRef.",
        ),
    ] = None


class Ref(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Ref"]:
            return Ref

        def build(self) -> "Ref":
            return Ref(**self._attrs)

        def branch(self, value: Optional[str]) -> Self:
            return self._set("branch", value)

        def commit(self, value: Optional[str]) -> Self:
            return self._set("commit", value)

        def name(self, value: Optional[str]) -> Self:
            return self._set("name", value)

        def semver(self, value: Optional[str]) -> Self:
            return self._set("semver", value)

        def tag(self, value: Optional[str]) -> Self:
            return self._set("tag", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Ref", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ref.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    branch: Annotated[
        Optional[str],
        Field(
            description="Branch to check out, defaults to 'master' if no other field is defined."
        ),
    ] = None
    commit: Annotated[
        Optional[str],
        Field(
            description="Commit SHA to check out, takes precedence over all reference fields.\n\nThis can be combined with Branch to shallow clone the branch, in which\nthe commit is expected to exist."
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description='Name of the reference to check out; takes precedence over Branch, Tag and SemVer.\n\nIt must be a valid Git reference: https://git-scm.com/docs/git-check-ref-format#_description\nExamples: "refs/heads/main", "refs/tags/v0.1.0", "refs/pull/420/head", "refs/merge-requests/1/head"'
        ),
    ] = None
    semver: Annotated[
        Optional[str],
        Field(description="SemVer tag expression to check out, takes precedence over Tag."),
    ] = None
    tag: Annotated[
        Optional[str],
        Field(description="Tag to check out, takes precedence over Branch."),
    ] = None


class Verify(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Verify"]:
            return Verify

        def build(self) -> "Verify":
            return Verify(**self._attrs)

        def mode(self, value: Literal["head"]) -> Self:
            return self._set("mode", value)

        def secret_ref(
            self,
            value_or_callback: Union[SecretRef, Callable[[SecretRef.Builder], SecretRef.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SecretRef.builder()).build()
            return self._set("secret_ref", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Verify", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Verify.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    mode: Annotated[
        Literal["head"],
        Field(description="Mode specifies what Git object should be verified, currently ('head')."),
    ]
    secret_ref: Annotated[
        SecretRef,
        Field(
            alias="secretRef",
            description="SecretRef specifies the Secret containing the public keys of trusted Git\nauthors.",
        ),
    ]


class GitRepositorySpec(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["GitRepositorySpec"]:
            return GitRepositorySpec

        def build(self) -> "GitRepositorySpec":
            return GitRepositorySpec(**self._attrs)

        def access_from(
            self,
            value_or_callback: Union[
                Optional[AccessFrom], Callable[[AccessFrom.Builder], AccessFrom.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(AccessFrom.builder()).build()
            return self._set("access_from", value)

        def git_implementation(self, value: Optional[Literal["go-git", "libgit2"]]) -> Self:
            return self._set("git_implementation", value)

        def ignore(self, value: Optional[str]) -> Self:
            return self._set("ignore", value)

        def include(
            self,
            value_or_callback: Union[
                Optional[List[Include]],
                Callable[
                    [GenericListBuilder[Include, Include.Builder]],
                    GenericListBuilder[Include, Include.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Include.list_builder()).build()
            return self._set("include", value)

        def interval(self, value: str) -> Self:
            return self._set("interval", value)

        def recurse_submodules(self, value: Optional[bool]) -> Self:
            return self._set("recurse_submodules", value)

        def ref(
            self,
            value_or_callback: Union[Optional[Ref], Callable[[Ref.Builder], Ref.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Ref.builder()).build()
            return self._set("ref", value)

        def secret_ref(
            self,
            value_or_callback: Union[
                Optional[SecretRef], Callable[[SecretRef.Builder], SecretRef.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SecretRef.builder()).build()
            return self._set("secret_ref", value)

        def suspend(self, value: Optional[bool]) -> Self:
            return self._set("suspend", value)

        def timeout(self, value: Optional[str]) -> Self:
            return self._set("timeout", value)

        def url(self, value: str) -> Self:
            return self._set("url", value)

        def verify(
            self,
            value_or_callback: Union[Optional[Verify], Callable[[Verify.Builder], Verify.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Verify.builder()).build()
            return self._set("verify", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["GitRepositorySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GitRepositorySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_from: Annotated[
        Optional[AccessFrom],
        Field(
            alias="accessFrom",
            description="AccessFrom specifies an Access Control List for allowing cross-namespace\nreferences to this object.\nNOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092",
        ),
    ] = None
    git_implementation: Annotated[
        Optional[Literal["go-git", "libgit2"]],
        Field(
            alias="gitImplementation",
            description="GitImplementation specifies which Git client library implementation to\nuse. Defaults to 'go-git', valid values are ('go-git', 'libgit2').\nDeprecated: gitImplementation is deprecated now that 'go-git' is the\nonly supported implementation.",
        ),
    ] = "go-git"
    ignore: Annotated[
        Optional[str],
        Field(
            description="Ignore overrides the set of excluded patterns in the .sourceignore format\n(which is the same as .gitignore). If not provided, a default will be used,\nconsult the documentation for your version to find out what those are."
        ),
    ] = None
    include: Annotated[
        Optional[List[Include]],
        Field(
            description="Include specifies a list of GitRepository resources which Artifacts\nshould be included in the Artifact produced for this GitRepository."
        ),
    ] = None
    interval: Annotated[
        str,
        Field(
            description="Interval at which to check the GitRepository for updates.",
            pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$",
        ),
    ]
    recurse_submodules: Annotated[
        Optional[bool],
        Field(
            alias="recurseSubmodules",
            description="RecurseSubmodules enables the initialization of all submodules within\nthe GitRepository as cloned from the URL, using their default settings.",
        ),
    ] = None
    ref: Annotated[
        Optional[Ref],
        Field(
            description="Reference specifies the Git reference to resolve and monitor for\nchanges, defaults to the 'master' branch."
        ),
    ] = None
    secret_ref: Annotated[
        Optional[SecretRef],
        Field(
            alias="secretRef",
            description="SecretRef specifies the Secret containing authentication credentials for\nthe GitRepository.\nFor HTTPS repositories the Secret must contain 'username' and 'password'\nfields for basic auth or 'bearerToken' field for token auth.\nFor SSH repositories the Secret must contain 'identity'\nand 'known_hosts' fields.",
        ),
    ] = None
    suspend: Annotated[
        Optional[bool],
        Field(
            description="Suspend tells the controller to suspend the reconciliation of this\nGitRepository."
        ),
    ] = None
    timeout: Annotated[
        Optional[str],
        Field(
            description="Timeout for Git operations like cloning, defaults to 60s.",
            pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m))+$",
        ),
    ] = "60s"
    url: Annotated[
        str,
        Field(
            description="URL specifies the Git repository URL, it can be an HTTP/S or SSH address.",
            pattern="^(http|https|ssh)://.*$",
        ),
    ]
    verify: Annotated[
        Optional[Verify],
        Field(
            description="Verification specifies the configuration to verify the Git commit\nsignature(s)."
        ),
    ] = None


class IncludedArtifact(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["IncludedArtifact"]:
            return IncludedArtifact

        def build(self) -> "IncludedArtifact":
            return IncludedArtifact(**self._attrs)

        def digest(self, value: Optional[str]) -> Self:
            return self._set("digest", value)

        def last_update_time(self, value: datetime) -> Self:
            return self._set("last_update_time", value)

        def metadata(self, value: Optional[Dict[str, str]]) -> Self:
            return self._set("metadata", value)

        def path(self, value: str) -> Self:
            return self._set("path", value)

        def revision(self, value: str) -> Self:
            return self._set("revision", value)

        def size(self, value: Optional[int]) -> Self:
            return self._set("size", value)

        def url(self, value: str) -> Self:
            return self._set("url", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["IncludedArtifact", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IncludedArtifact.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    digest: Annotated[
        Optional[str],
        Field(
            description="Digest is the digest of the file in the form of '<algorithm>:<checksum>'.",
            pattern="^[a-z0-9]+(?:[.+_-][a-z0-9]+)*:[a-zA-Z0-9=_-]+$",
        ),
    ] = None
    last_update_time: Annotated[
        datetime,
        Field(
            alias="lastUpdateTime",
            description="LastUpdateTime is the timestamp corresponding to the last update of the\nArtifact.",
        ),
    ]
    metadata: Annotated[
        Optional[Dict[str, str]],
        Field(description="Metadata holds upstream information such as OCI annotations."),
    ] = None
    path: Annotated[
        str,
        Field(
            description="Path is the relative file path of the Artifact. It can be used to locate\nthe file in the root of the Artifact storage on the local file system of\nthe controller managing the Source."
        ),
    ]
    revision: Annotated[
        str,
        Field(
            description="Revision is a human-readable identifier traceable in the origin source\nsystem. It can be a Git commit SHA, Git tag, a Helm chart version, etc."
        ),
    ]
    size: Annotated[
        Optional[int], Field(description="Size is the number of bytes in the file.")
    ] = None
    url: Annotated[
        str,
        Field(
            description="URL is the HTTP address of the Artifact as exposed by the controller\nmanaging the Source. It can be used to retrieve the Artifact for\nconsumption, e.g. by another controller applying the Artifact contents."
        ),
    ]


class ObservedInclude(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["ObservedInclude"]:
            return ObservedInclude

        def build(self) -> "ObservedInclude":
            return ObservedInclude(**self._attrs)

        def from_path(self, value: Optional[str]) -> Self:
            return self._set("from_path", value)

        def repository(
            self,
            value_or_callback: Union[
                Repository, Callable[[Repository.Builder], Repository.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Repository.builder()).build()
            return self._set("repository", value)

        def to_path(self, value: Optional[str]) -> Self:
            return self._set("to_path", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["ObservedInclude", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ObservedInclude.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    from_path: Annotated[
        Optional[str],
        Field(
            alias="fromPath",
            description="FromPath specifies the path to copy contents from, defaults to the root\nof the Artifact.",
        ),
    ] = None
    repository: Annotated[
        Repository,
        Field(
            description="GitRepositoryRef specifies the GitRepository which Artifact contents\nmust be included."
        ),
    ]
    to_path: Annotated[
        Optional[str],
        Field(
            alias="toPath",
            description="ToPath specifies the path to copy contents to, defaults to the name of\nthe GitRepositoryRef.",
        ),
    ] = None


class GitRepositoryStatus(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["GitRepositoryStatus"]:
            return GitRepositoryStatus

        def build(self) -> "GitRepositoryStatus":
            return GitRepositoryStatus(**self._attrs)

        def artifact(
            self,
            value_or_callback: Union[
                Optional[Artifact], Callable[[Artifact.Builder], Artifact.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Artifact.builder()).build()
            return self._set("artifact", value)

        def conditions(
            self,
            value_or_callback: Union[
                Optional[List[Condition]],
                Callable[
                    [GenericListBuilder[Condition, Condition.Builder]],
                    GenericListBuilder[Condition, Condition.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Condition.list_builder()).build()
            return self._set("conditions", value)

        def content_config_checksum(self, value: Optional[str]) -> Self:
            return self._set("content_config_checksum", value)

        def included_artifacts(
            self,
            value_or_callback: Union[
                Optional[List[IncludedArtifact]],
                Callable[
                    [GenericListBuilder[IncludedArtifact, IncludedArtifact.Builder]],
                    GenericListBuilder[IncludedArtifact, IncludedArtifact.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(IncludedArtifact.list_builder()).build()
            return self._set("included_artifacts", value)

        def last_handled_reconcile_at(self, value: Optional[str]) -> Self:
            return self._set("last_handled_reconcile_at", value)

        def observed_generation(self, value: Optional[int]) -> Self:
            return self._set("observed_generation", value)

        def observed_ignore(self, value: Optional[str]) -> Self:
            return self._set("observed_ignore", value)

        def observed_include(
            self,
            value_or_callback: Union[
                Optional[List[ObservedInclude]],
                Callable[
                    [GenericListBuilder[ObservedInclude, ObservedInclude.Builder]],
                    GenericListBuilder[ObservedInclude, ObservedInclude.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(ObservedInclude.list_builder()).build()
            return self._set("observed_include", value)

        def observed_recurse_submodules(self, value: Optional[bool]) -> Self:
            return self._set("observed_recurse_submodules", value)

        def url(self, value: Optional[str]) -> Self:
            return self._set("url", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["GitRepositoryStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GitRepositoryStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    artifact: Annotated[
        Optional[Artifact],
        Field(description="Artifact represents the last successful GitRepository reconciliation."),
    ] = None
    conditions: Annotated[
        Optional[List[Condition]],
        Field(description="Conditions holds the conditions for the GitRepository."),
    ] = None
    content_config_checksum: Annotated[
        Optional[str],
        Field(
            alias="contentConfigChecksum",
            description="ContentConfigChecksum is a checksum of all the configurations related to\nthe content of the source artifact:\n - .spec.ignore\n - .spec.recurseSubmodules\n - .spec.included and the checksum of the included artifacts\nobserved in .status.observedGeneration version of the object. This can\nbe used to determine if the content of the included repository has\nchanged.\nIt has the format of `<algo>:<checksum>`, for example: `sha256:<checksum>`.\n\nDeprecated: Replaced with explicit fields for observed artifact content\nconfig in the status.",
        ),
    ] = None
    included_artifacts: Annotated[
        Optional[List[IncludedArtifact]],
        Field(
            alias="includedArtifacts",
            description="IncludedArtifacts contains a list of the last successfully included\nArtifacts as instructed by GitRepositorySpec.Include.",
        ),
    ] = None
    last_handled_reconcile_at: Annotated[
        Optional[str],
        Field(
            alias="lastHandledReconcileAt",
            description="LastHandledReconcileAt holds the value of the most recent\nreconcile request value, so a change of the annotation value\ncan be detected.",
        ),
    ] = None
    observed_generation: Annotated[
        Optional[int],
        Field(
            alias="observedGeneration",
            description="ObservedGeneration is the last observed generation of the GitRepository\nobject.",
        ),
    ] = None
    observed_ignore: Annotated[
        Optional[str],
        Field(
            alias="observedIgnore",
            description="ObservedIgnore is the observed exclusion patterns used for constructing\nthe source artifact.",
        ),
    ] = None
    observed_include: Annotated[
        Optional[List[ObservedInclude]],
        Field(
            alias="observedInclude",
            description="ObservedInclude is the observed list of GitRepository resources used to\nto produce the current Artifact.",
        ),
    ] = None
    observed_recurse_submodules: Annotated[
        Optional[bool],
        Field(
            alias="observedRecurseSubmodules",
            description="ObservedRecurseSubmodules is the observed resource submodules\nconfiguration used to produce the current Artifact.",
        ),
    ] = None
    url: Annotated[
        Optional[str],
        Field(
            description='URL is the dynamic fetch link for the latest Artifact.\nIt is provided on a "best effort" basis, and using the precise\nGitRepositoryStatus.Artifact data is recommended.'
        ),
    ] = None


class SourceRef(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["SourceRef"]:
            return SourceRef

        def build(self) -> "SourceRef":
            return SourceRef(**self._attrs)

        def api_version(self, value: Optional[str]) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Literal["HelmRepository", "GitRepository", "Bucket"]) -> Self:
            return self._set("kind", value)

        def name(self, value: str) -> Self:
            return self._set("name", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["SourceRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SourceRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[str],
        Field(alias="apiVersion", description="APIVersion of the referent."),
    ] = None
    kind: Annotated[
        Literal["HelmRepository", "GitRepository", "Bucket"],
        Field(
            description="Kind of the referent, valid values are ('HelmRepository', 'GitRepository',\n'Bucket')."
        ),
    ]
    name: Annotated[str, Field(description="Name of the referent.")]


class MatchOidcIdentity(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["MatchOidcIdentity"]:
            return MatchOidcIdentity

        def build(self) -> "MatchOidcIdentity":
            return MatchOidcIdentity(**self._attrs)

        def issuer(self, value: str) -> Self:
            return self._set("issuer", value)

        def subject(self, value: str) -> Self:
            return self._set("subject", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["MatchOidcIdentity", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchOidcIdentity.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    issuer: Annotated[
        str,
        Field(
            description="Issuer specifies the regex pattern to match against to verify\nthe OIDC issuer in the Fulcio certificate. The pattern must be a\nvalid Go regular expression."
        ),
    ]
    subject: Annotated[
        str,
        Field(
            description="Subject specifies the regex pattern to match against to verify\nthe identity subject in the Fulcio certificate. The pattern must\nbe a valid Go regular expression."
        ),
    ]


class VerifyModel(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["VerifyModel"]:
            return VerifyModel

        def build(self) -> "VerifyModel":
            return VerifyModel(**self._attrs)

        def match_oidc_identity(
            self,
            value_or_callback: Union[
                Optional[List[MatchOidcIdentity]],
                Callable[
                    [GenericListBuilder[MatchOidcIdentity, MatchOidcIdentity.Builder]],
                    GenericListBuilder[MatchOidcIdentity, MatchOidcIdentity.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(MatchOidcIdentity.list_builder()).build()
            return self._set("match_oidc_identity", value)

        def provider(self, value: Optional[Literal["cosign", "notation"]]) -> Self:
            return self._set("provider", value)

        def secret_ref(
            self,
            value_or_callback: Union[
                Optional[SecretRef], Callable[[SecretRef.Builder], SecretRef.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SecretRef.builder()).build()
            return self._set("secret_ref", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["VerifyModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VerifyModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_oidc_identity: Annotated[
        Optional[List[MatchOidcIdentity]],
        Field(
            alias="matchOIDCIdentity",
            description="MatchOIDCIdentity specifies the identity matching criteria to use\nwhile verifying an OCI artifact which was signed using Cosign keyless\nsigning. The artifact's identity is deemed to be verified if any of the\nspecified matchers match against the identity.",
        ),
    ] = None
    provider: Annotated[
        Optional[Literal["cosign", "notation"]],
        Field(description="Provider specifies the technology used to sign the OCI Artifact."),
    ] = "cosign"
    secret_ref: Annotated[
        Optional[SecretRef],
        Field(
            alias="secretRef",
            description="SecretRef specifies the Kubernetes Secret containing the\ntrusted public keys.",
        ),
    ] = None


class HelmChartSpec(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["HelmChartSpec"]:
            return HelmChartSpec

        def build(self) -> "HelmChartSpec":
            return HelmChartSpec(**self._attrs)

        def access_from(
            self,
            value_or_callback: Union[
                Optional[AccessFrom], Callable[[AccessFrom.Builder], AccessFrom.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(AccessFrom.builder()).build()
            return self._set("access_from", value)

        def chart(self, value: str) -> Self:
            return self._set("chart", value)

        def ignore_missing_values_files(self, value: Optional[bool]) -> Self:
            return self._set("ignore_missing_values_files", value)

        def interval(self, value: str) -> Self:
            return self._set("interval", value)

        def reconcile_strategy(self, value: Optional[Literal["ChartVersion", "Revision"]]) -> Self:
            return self._set("reconcile_strategy", value)

        def source_ref(
            self,
            value_or_callback: Union[SourceRef, Callable[[SourceRef.Builder], SourceRef.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SourceRef.builder()).build()
            return self._set("source_ref", value)

        def suspend(self, value: Optional[bool]) -> Self:
            return self._set("suspend", value)

        def values_file(self, value: Optional[str]) -> Self:
            return self._set("values_file", value)

        def values_files(self, value: Optional[List[str]]) -> Self:
            return self._set("values_files", value)

        def verify(
            self,
            value_or_callback: Union[
                Optional[VerifyModel],
                Callable[[VerifyModel.Builder], VerifyModel.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(VerifyModel.builder()).build()
            return self._set("verify", value)

        def version(self, value: Optional[str]) -> Self:
            return self._set("version", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["HelmChartSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmChartSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_from: Annotated[
        Optional[AccessFrom],
        Field(
            alias="accessFrom",
            description="AccessFrom specifies an Access Control List for allowing cross-namespace\nreferences to this object.\nNOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092",
        ),
    ] = None
    chart: Annotated[
        str,
        Field(
            description="Chart is the name or path the Helm chart is available at in the\nSourceRef."
        ),
    ]
    ignore_missing_values_files: Annotated[
        Optional[bool],
        Field(
            alias="ignoreMissingValuesFiles",
            description="IgnoreMissingValuesFiles controls whether to silently ignore missing values\nfiles rather than failing.",
        ),
    ] = None
    interval: Annotated[
        str,
        Field(
            description="Interval at which the HelmChart SourceRef is checked for updates.\nThis interval is approximate and may be subject to jitter to ensure\nefficient use of resources.",
            pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$",
        ),
    ]
    reconcile_strategy: Annotated[
        Optional[Literal["ChartVersion", "Revision"]],
        Field(
            alias="reconcileStrategy",
            description="ReconcileStrategy determines what enables the creation of a new artifact.\nValid values are ('ChartVersion', 'Revision').\nSee the documentation of the values for an explanation on their behavior.\nDefaults to ChartVersion when omitted.",
        ),
    ] = "ChartVersion"
    source_ref: Annotated[
        SourceRef,
        Field(
            alias="sourceRef",
            description="SourceRef is the reference to the Source the chart is available at.",
        ),
    ]
    suspend: Annotated[
        Optional[bool],
        Field(
            description="Suspend tells the controller to suspend the reconciliation of this\nsource."
        ),
    ] = None
    values_file: Annotated[
        Optional[str],
        Field(
            alias="valuesFile",
            description="ValuesFile is an alternative values file to use as the default chart\nvalues, expected to be a relative path in the SourceRef. Deprecated in\nfavor of ValuesFiles, for backwards compatibility the file specified here\nis merged before the ValuesFiles items. Ignored when omitted.",
        ),
    ] = None
    values_files: Annotated[
        Optional[List[str]],
        Field(
            alias="valuesFiles",
            description="ValuesFiles is an alternative list of values files to use as the chart\nvalues (values.yaml is not included by default), expected to be a\nrelative path in the SourceRef.\nValues files are merged in the order of this list with the last file\noverriding the first. Ignored when omitted.",
        ),
    ] = None
    verify: Annotated[
        Optional[VerifyModel],
        Field(
            description="Verify contains the secret name containing the trusted public keys\nused to verify the signature and specifies which provider to use to check\nwhether OCI image is authentic.\nThis field is only supported when using HelmRepository source with spec.type 'oci'.\nChart dependencies, which are not bundled in the umbrella chart artifact, are not verified."
        ),
    ] = None
    version: Annotated[
        Optional[str],
        Field(
            description="Version is the chart version semver expression, ignored for charts from\nGitRepository and Bucket sources. Defaults to latest when omitted."
        ),
    ] = "*"


class HelmChartStatus(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["HelmChartStatus"]:
            return HelmChartStatus

        def build(self) -> "HelmChartStatus":
            return HelmChartStatus(**self._attrs)

        def artifact(
            self,
            value_or_callback: Union[
                Optional[Artifact], Callable[[Artifact.Builder], Artifact.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Artifact.builder()).build()
            return self._set("artifact", value)

        def conditions(
            self,
            value_or_callback: Union[
                Optional[List[Condition]],
                Callable[
                    [GenericListBuilder[Condition, Condition.Builder]],
                    GenericListBuilder[Condition, Condition.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Condition.list_builder()).build()
            return self._set("conditions", value)

        def last_handled_reconcile_at(self, value: Optional[str]) -> Self:
            return self._set("last_handled_reconcile_at", value)

        def observed_chart_name(self, value: Optional[str]) -> Self:
            return self._set("observed_chart_name", value)

        def observed_generation(self, value: Optional[int]) -> Self:
            return self._set("observed_generation", value)

        def observed_source_artifact_revision(self, value: Optional[str]) -> Self:
            return self._set("observed_source_artifact_revision", value)

        def observed_values_files(self, value: Optional[List[str]]) -> Self:
            return self._set("observed_values_files", value)

        def url(self, value: Optional[str]) -> Self:
            return self._set("url", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["HelmChartStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmChartStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    artifact: Annotated[
        Optional[Artifact],
        Field(description="Artifact represents the output of the last successful reconciliation."),
    ] = None
    conditions: Annotated[
        Optional[List[Condition]],
        Field(description="Conditions holds the conditions for the HelmChart."),
    ] = None
    last_handled_reconcile_at: Annotated[
        Optional[str],
        Field(
            alias="lastHandledReconcileAt",
            description="LastHandledReconcileAt holds the value of the most recent\nreconcile request value, so a change of the annotation value\ncan be detected.",
        ),
    ] = None
    observed_chart_name: Annotated[
        Optional[str],
        Field(
            alias="observedChartName",
            description="ObservedChartName is the last observed chart name as specified by the\nresolved chart reference.",
        ),
    ] = None
    observed_generation: Annotated[
        Optional[int],
        Field(
            alias="observedGeneration",
            description="ObservedGeneration is the last observed generation of the HelmChart\nobject.",
        ),
    ] = None
    observed_source_artifact_revision: Annotated[
        Optional[str],
        Field(
            alias="observedSourceArtifactRevision",
            description="ObservedSourceArtifactRevision is the last observed Artifact.Revision\nof the HelmChartSpec.SourceRef.",
        ),
    ] = None
    observed_values_files: Annotated[
        Optional[List[str]],
        Field(
            alias="observedValuesFiles",
            description="ObservedValuesFiles are the observed value files of the last successful\nreconciliation.\nIt matches the chart in the last successfully reconciled artifact.",
        ),
    ] = None
    url: Annotated[
        Optional[str],
        Field(
            description='URL is the dynamic fetch link for the latest Artifact.\nIt is provided on a "best effort" basis, and using the precise\nBucketStatus.Artifact data is recommended.'
        ),
    ] = None


class HelmRepositorySpec(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["HelmRepositorySpec"]:
            return HelmRepositorySpec

        def build(self) -> "HelmRepositorySpec":
            return HelmRepositorySpec(**self._attrs)

        def access_from(
            self,
            value_or_callback: Union[
                Optional[AccessFrom], Callable[[AccessFrom.Builder], AccessFrom.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(AccessFrom.builder()).build()
            return self._set("access_from", value)

        def cert_secret_ref(
            self,
            value_or_callback: Union[
                Optional[CertSecretRef],
                Callable[[CertSecretRef.Builder], CertSecretRef.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(CertSecretRef.builder()).build()
            return self._set("cert_secret_ref", value)

        def insecure(self, value: Optional[bool]) -> Self:
            return self._set("insecure", value)

        def interval(self, value: Optional[str]) -> Self:
            return self._set("interval", value)

        def pass_credentials(self, value: Optional[bool]) -> Self:
            return self._set("pass_credentials", value)

        def provider(self, value: Optional[Literal["generic", "aws", "azure", "gcp"]]) -> Self:
            return self._set("provider", value)

        def secret_ref(
            self,
            value_or_callback: Union[
                Optional[SecretRef], Callable[[SecretRef.Builder], SecretRef.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SecretRef.builder()).build()
            return self._set("secret_ref", value)

        def suspend(self, value: Optional[bool]) -> Self:
            return self._set("suspend", value)

        def timeout(self, value: Optional[str]) -> Self:
            return self._set("timeout", value)

        def type(self, value: Optional[Literal["default", "oci"]]) -> Self:
            return self._set("type", value)

        def url(self, value: str) -> Self:
            return self._set("url", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["HelmRepositorySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmRepositorySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_from: Annotated[
        Optional[AccessFrom],
        Field(
            alias="accessFrom",
            description="AccessFrom specifies an Access Control List for allowing cross-namespace\nreferences to this object.\nNOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092",
        ),
    ] = None
    cert_secret_ref: Annotated[
        Optional[CertSecretRef],
        Field(
            alias="certSecretRef",
            description="CertSecretRef can be given the name of a Secret containing\neither or both of\n\n- a PEM-encoded client certificate (`tls.crt`) and private\nkey (`tls.key`);\n- a PEM-encoded CA certificate (`ca.crt`)\n\nand whichever are supplied, will be used for connecting to the\nregistry. The client cert and key are useful if you are\nauthenticating with a certificate; the CA cert is useful if\nyou are using a self-signed server certificate. The Secret must\nbe of type `Opaque` or `kubernetes.io/tls`.\n\nIt takes precedence over the values specified in the Secret referred\nto by `.spec.secretRef`.",
        ),
    ] = None
    insecure: Annotated[
        Optional[bool],
        Field(
            description="Insecure allows connecting to a non-TLS HTTP container registry.\nThis field is only taken into account if the .spec.type field is set to 'oci'."
        ),
    ] = None
    interval: Annotated[
        Optional[str],
        Field(
            description="Interval at which the HelmRepository URL is checked for updates.\nThis interval is approximate and may be subject to jitter to ensure\nefficient use of resources.",
            pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$",
        ),
    ] = None
    pass_credentials: Annotated[
        Optional[bool],
        Field(
            alias="passCredentials",
            description="PassCredentials allows the credentials from the SecretRef to be passed\non to a host that does not match the host as defined in URL.\nThis may be required if the host of the advertised chart URLs in the\nindex differ from the defined URL.\nEnabling this should be done with caution, as it can potentially result\nin credentials getting stolen in a MITM-attack.",
        ),
    ] = None
    provider: Annotated[
        Optional[Literal["generic", "aws", "azure", "gcp"]],
        Field(
            description="Provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'.\nThis field is optional, and only taken into account if the .spec.type field is set to 'oci'.\nWhen not specified, defaults to 'generic'."
        ),
    ] = "generic"
    secret_ref: Annotated[
        Optional[SecretRef],
        Field(
            alias="secretRef",
            description="SecretRef specifies the Secret containing authentication credentials\nfor the HelmRepository.\nFor HTTP/S basic auth the secret must contain 'username' and 'password'\nfields.\nSupport for TLS auth using the 'certFile' and 'keyFile', and/or 'caFile'\nkeys is deprecated. Please use `.spec.certSecretRef` instead.",
        ),
    ] = None
    suspend: Annotated[
        Optional[bool],
        Field(
            description="Suspend tells the controller to suspend the reconciliation of this\nHelmRepository."
        ),
    ] = None
    timeout: Annotated[
        Optional[str],
        Field(
            description="Timeout is used for the index fetch operation for an HTTPS helm repository,\nand for remote OCI Repository operations like pulling for an OCI helm\nchart by the associated HelmChart.\nIts default value is 60s.",
            pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m))+$",
        ),
    ] = None
    type: Annotated[
        Optional[Literal["default", "oci"]],
        Field(
            description='Type of the HelmRepository.\nWhen this field is set to  "oci", the URL field value must be prefixed with "oci://".'
        ),
    ] = None
    url: Annotated[
        str,
        Field(
            description="URL of the Helm repository, a valid URL contains at least a protocol and\nhost.",
            pattern="^(http|https|oci)://.*$",
        ),
    ]


class HelmRepositoryStatus(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["HelmRepositoryStatus"]:
            return HelmRepositoryStatus

        def build(self) -> "HelmRepositoryStatus":
            return HelmRepositoryStatus(**self._attrs)

        def artifact(
            self,
            value_or_callback: Union[
                Optional[Artifact], Callable[[Artifact.Builder], Artifact.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Artifact.builder()).build()
            return self._set("artifact", value)

        def conditions(
            self,
            value_or_callback: Union[
                Optional[List[Condition]],
                Callable[
                    [GenericListBuilder[Condition, Condition.Builder]],
                    GenericListBuilder[Condition, Condition.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Condition.list_builder()).build()
            return self._set("conditions", value)

        def last_handled_reconcile_at(self, value: Optional[str]) -> Self:
            return self._set("last_handled_reconcile_at", value)

        def observed_generation(self, value: Optional[int]) -> Self:
            return self._set("observed_generation", value)

        def url(self, value: Optional[str]) -> Self:
            return self._set("url", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["HelmRepositoryStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmRepositoryStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    artifact: Annotated[
        Optional[Artifact],
        Field(description="Artifact represents the last successful HelmRepository reconciliation."),
    ] = None
    conditions: Annotated[
        Optional[List[Condition]],
        Field(description="Conditions holds the conditions for the HelmRepository."),
    ] = None
    last_handled_reconcile_at: Annotated[
        Optional[str],
        Field(
            alias="lastHandledReconcileAt",
            description="LastHandledReconcileAt holds the value of the most recent\nreconcile request value, so a change of the annotation value\ncan be detected.",
        ),
    ] = None
    observed_generation: Annotated[
        Optional[int],
        Field(
            alias="observedGeneration",
            description="ObservedGeneration is the last observed generation of the HelmRepository\nobject.",
        ),
    ] = None
    url: Annotated[
        Optional[str],
        Field(
            description='URL is the dynamic fetch link for the latest Artifact.\nIt is provided on a "best effort" basis, and using the precise\nHelmRepositoryStatus.Artifact data is recommended.'
        ),
    ] = None


class LayerSelector(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["LayerSelector"]:
            return LayerSelector

        def build(self) -> "LayerSelector":
            return LayerSelector(**self._attrs)

        def media_type(self, value: Optional[str]) -> Self:
            return self._set("media_type", value)

        def operation(self, value: Optional[Literal["extract", "copy"]]) -> Self:
            return self._set("operation", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["LayerSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LayerSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    media_type: Annotated[
        Optional[str],
        Field(
            alias="mediaType",
            description="MediaType specifies the OCI media type of the layer\nwhich should be extracted from the OCI Artifact. The\nfirst layer matching this type is selected.",
        ),
    ] = None
    operation: Annotated[
        Optional[Literal["extract", "copy"]],
        Field(
            description="Operation specifies how the selected layer should be processed.\nBy default, the layer compressed content is extracted to storage.\nWhen the operation is set to 'copy', the layer compressed content\nis persisted to storage as it is."
        ),
    ] = None


class RefModel(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["RefModel"]:
            return RefModel

        def build(self) -> "RefModel":
            return RefModel(**self._attrs)

        def digest(self, value: Optional[str]) -> Self:
            return self._set("digest", value)

        def semver(self, value: Optional[str]) -> Self:
            return self._set("semver", value)

        def semver_filter(self, value: Optional[str]) -> Self:
            return self._set("semver_filter", value)

        def tag(self, value: Optional[str]) -> Self:
            return self._set("tag", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["RefModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RefModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    digest: Annotated[
        Optional[str],
        Field(
            description="Digest is the image digest to pull, takes precedence over SemVer.\nThe value should be in the format 'sha256:<HASH>'."
        ),
    ] = None
    semver: Annotated[
        Optional[str],
        Field(
            description="SemVer is the range of tags to pull selecting the latest within\nthe range, takes precedence over Tag."
        ),
    ] = None
    semver_filter: Annotated[
        Optional[str],
        Field(
            alias="semverFilter",
            description="SemverFilter is a regex pattern to filter the tags within the SemVer range.",
        ),
    ] = None
    tag: Annotated[
        Optional[str],
        Field(description="Tag is the image tag to pull, defaults to latest."),
    ] = None


class OCIRepositorySpec(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["OCIRepositorySpec"]:
            return OCIRepositorySpec

        def build(self) -> "OCIRepositorySpec":
            return OCIRepositorySpec(**self._attrs)

        def cert_secret_ref(
            self,
            value_or_callback: Union[
                Optional[CertSecretRef],
                Callable[[CertSecretRef.Builder], CertSecretRef.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(CertSecretRef.builder()).build()
            return self._set("cert_secret_ref", value)

        def ignore(self, value: Optional[str]) -> Self:
            return self._set("ignore", value)

        def insecure(self, value: Optional[bool]) -> Self:
            return self._set("insecure", value)

        def interval(self, value: str) -> Self:
            return self._set("interval", value)

        def layer_selector(
            self,
            value_or_callback: Union[
                Optional[LayerSelector],
                Callable[[LayerSelector.Builder], LayerSelector.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(LayerSelector.builder()).build()
            return self._set("layer_selector", value)

        def provider(self, value: Optional[Literal["generic", "aws", "azure", "gcp"]]) -> Self:
            return self._set("provider", value)

        def proxy_secret_ref(
            self,
            value_or_callback: Union[
                Optional[ProxySecretRef],
                Callable[[ProxySecretRef.Builder], ProxySecretRef.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(ProxySecretRef.builder()).build()
            return self._set("proxy_secret_ref", value)

        def ref(
            self,
            value_or_callback: Union[
                Optional[RefModel], Callable[[RefModel.Builder], RefModel.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(RefModel.builder()).build()
            return self._set("ref", value)

        def secret_ref(
            self,
            value_or_callback: Union[
                Optional[SecretRef], Callable[[SecretRef.Builder], SecretRef.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SecretRef.builder()).build()
            return self._set("secret_ref", value)

        def service_account_name(self, value: Optional[str]) -> Self:
            return self._set("service_account_name", value)

        def suspend(self, value: Optional[bool]) -> Self:
            return self._set("suspend", value)

        def timeout(self, value: Optional[str]) -> Self:
            return self._set("timeout", value)

        def url(self, value: str) -> Self:
            return self._set("url", value)

        def verify(
            self,
            value_or_callback: Union[
                Optional[VerifyModel],
                Callable[[VerifyModel.Builder], VerifyModel.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(VerifyModel.builder()).build()
            return self._set("verify", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["OCIRepositorySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use OCIRepositorySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cert_secret_ref: Annotated[
        Optional[CertSecretRef],
        Field(
            alias="certSecretRef",
            description="CertSecretRef can be given the name of a Secret containing\neither or both of\n\n- a PEM-encoded client certificate (`tls.crt`) and private\nkey (`tls.key`);\n- a PEM-encoded CA certificate (`ca.crt`)\n\nand whichever are supplied, will be used for connecting to the\nregistry. The client cert and key are useful if you are\nauthenticating with a certificate; the CA cert is useful if\nyou are using a self-signed server certificate. The Secret must\nbe of type `Opaque` or `kubernetes.io/tls`.\n\nNote: Support for the `caFile`, `certFile` and `keyFile` keys have\nbeen deprecated.",
        ),
    ] = None
    ignore: Annotated[
        Optional[str],
        Field(
            description="Ignore overrides the set of excluded patterns in the .sourceignore format\n(which is the same as .gitignore). If not provided, a default will be used,\nconsult the documentation for your version to find out what those are."
        ),
    ] = None
    insecure: Annotated[
        Optional[bool],
        Field(description="Insecure allows connecting to a non-TLS HTTP container registry."),
    ] = None
    interval: Annotated[
        str,
        Field(
            description="Interval at which the OCIRepository URL is checked for updates.\nThis interval is approximate and may be subject to jitter to ensure\nefficient use of resources.",
            pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$",
        ),
    ]
    layer_selector: Annotated[
        Optional[LayerSelector],
        Field(
            alias="layerSelector",
            description="LayerSelector specifies which layer should be extracted from the OCI artifact.\nWhen not specified, the first layer found in the artifact is selected.",
        ),
    ] = None
    provider: Annotated[
        Optional[Literal["generic", "aws", "azure", "gcp"]],
        Field(
            description="The provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'.\nWhen not specified, defaults to 'generic'."
        ),
    ] = "generic"
    proxy_secret_ref: Annotated[
        Optional[ProxySecretRef],
        Field(
            alias="proxySecretRef",
            description="ProxySecretRef specifies the Secret containing the proxy configuration\nto use while communicating with the container registry.",
        ),
    ] = None
    ref: Annotated[
        Optional[RefModel],
        Field(
            description="The OCI reference to pull and monitor for changes,\ndefaults to the latest tag."
        ),
    ] = None
    secret_ref: Annotated[
        Optional[SecretRef],
        Field(
            alias="secretRef",
            description="SecretRef contains the secret name containing the registry login\ncredentials to resolve image metadata.\nThe secret must be of type kubernetes.io/dockerconfigjson.",
        ),
    ] = None
    service_account_name: Annotated[
        Optional[str],
        Field(
            alias="serviceAccountName",
            description="ServiceAccountName is the name of the Kubernetes ServiceAccount used to authenticate\nthe image pull if the service account has attached pull secrets. For more information:\nhttps://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account",
        ),
    ] = None
    suspend: Annotated[
        Optional[bool],
        Field(
            description="This flag tells the controller to suspend the reconciliation of this source."
        ),
    ] = None
    timeout: Annotated[
        Optional[str],
        Field(
            description="The timeout for remote OCI Repository operations like pulling, defaults to 60s.",
            pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m))+$",
        ),
    ] = "60s"
    url: Annotated[
        str,
        Field(
            description="URL is a reference to an OCI artifact repository hosted\non a remote container registry.",
            pattern="^oci://.*$",
        ),
    ]
    verify: Annotated[
        Optional[VerifyModel],
        Field(
            description="Verify contains the secret name containing the trusted public keys\nused to verify the signature and specifies which provider to use to check\nwhether OCI image is authentic."
        ),
    ] = None


class ObservedLayerSelector(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["ObservedLayerSelector"]:
            return ObservedLayerSelector

        def build(self) -> "ObservedLayerSelector":
            return ObservedLayerSelector(**self._attrs)

        def media_type(self, value: Optional[str]) -> Self:
            return self._set("media_type", value)

        def operation(self, value: Optional[Literal["extract", "copy"]]) -> Self:
            return self._set("operation", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["ObservedLayerSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ObservedLayerSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    media_type: Annotated[
        Optional[str],
        Field(
            alias="mediaType",
            description="MediaType specifies the OCI media type of the layer\nwhich should be extracted from the OCI Artifact. The\nfirst layer matching this type is selected.",
        ),
    ] = None
    operation: Annotated[
        Optional[Literal["extract", "copy"]],
        Field(
            description="Operation specifies how the selected layer should be processed.\nBy default, the layer compressed content is extracted to storage.\nWhen the operation is set to 'copy', the layer compressed content\nis persisted to storage as it is."
        ),
    ] = None


class OCIRepositoryStatus(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["OCIRepositoryStatus"]:
            return OCIRepositoryStatus

        def build(self) -> "OCIRepositoryStatus":
            return OCIRepositoryStatus(**self._attrs)

        def artifact(
            self,
            value_or_callback: Union[
                Optional[Artifact], Callable[[Artifact.Builder], Artifact.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Artifact.builder()).build()
            return self._set("artifact", value)

        def conditions(
            self,
            value_or_callback: Union[
                Optional[List[Condition]],
                Callable[
                    [GenericListBuilder[Condition, Condition.Builder]],
                    GenericListBuilder[Condition, Condition.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Condition.list_builder()).build()
            return self._set("conditions", value)

        def content_config_checksum(self, value: Optional[str]) -> Self:
            return self._set("content_config_checksum", value)

        def last_handled_reconcile_at(self, value: Optional[str]) -> Self:
            return self._set("last_handled_reconcile_at", value)

        def observed_generation(self, value: Optional[int]) -> Self:
            return self._set("observed_generation", value)

        def observed_ignore(self, value: Optional[str]) -> Self:
            return self._set("observed_ignore", value)

        def observed_layer_selector(
            self,
            value_or_callback: Union[
                Optional[ObservedLayerSelector],
                Callable[[ObservedLayerSelector.Builder], ObservedLayerSelector.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(ObservedLayerSelector.builder()).build()
            return self._set("observed_layer_selector", value)

        def url(self, value: Optional[str]) -> Self:
            return self._set("url", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["OCIRepositoryStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use OCIRepositoryStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    artifact: Annotated[
        Optional[Artifact],
        Field(
            description="Artifact represents the output of the last successful OCI Repository sync."
        ),
    ] = None
    conditions: Annotated[
        Optional[List[Condition]],
        Field(description="Conditions holds the conditions for the OCIRepository."),
    ] = None
    content_config_checksum: Annotated[
        Optional[str],
        Field(
            alias="contentConfigChecksum",
            description="ContentConfigChecksum is a checksum of all the configurations related to\nthe content of the source artifact:\n - .spec.ignore\n - .spec.layerSelector\nobserved in .status.observedGeneration version of the object. This can\nbe used to determine if the content configuration has changed and the\nartifact needs to be rebuilt.\nIt has the format of `<algo>:<checksum>`, for example: `sha256:<checksum>`.\n\nDeprecated: Replaced with explicit fields for observed artifact content\nconfig in the status.",
        ),
    ] = None
    last_handled_reconcile_at: Annotated[
        Optional[str],
        Field(
            alias="lastHandledReconcileAt",
            description="LastHandledReconcileAt holds the value of the most recent\nreconcile request value, so a change of the annotation value\ncan be detected.",
        ),
    ] = None
    observed_generation: Annotated[
        Optional[int],
        Field(
            alias="observedGeneration",
            description="ObservedGeneration is the last observed generation.",
        ),
    ] = None
    observed_ignore: Annotated[
        Optional[str],
        Field(
            alias="observedIgnore",
            description="ObservedIgnore is the observed exclusion patterns used for constructing\nthe source artifact.",
        ),
    ] = None
    observed_layer_selector: Annotated[
        Optional[ObservedLayerSelector],
        Field(
            alias="observedLayerSelector",
            description="ObservedLayerSelector is the observed layer selector used for constructing\nthe source artifact.",
        ),
    ] = None
    url: Annotated[
        Optional[str],
        Field(
            description="URL is the download link for the artifact output of the last OCI Repository sync."
        ),
    ] = None


class Bucket(Resource):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Bucket"]:
            return Bucket

        def build(self) -> "Bucket":
            return Bucket(**self._attrs)

        def api_version(self, value: Optional[Literal["source.toolkit.fluxcd.io/v1beta2"]]) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Bucket"]]) -> Self:
            return self._set("kind", value)

        def metadata(
            self,
            value_or_callback: Union[
                Optional[apimachinery.ObjectMeta],
                Callable[[apimachinery.ObjectMeta.Builder], apimachinery.ObjectMeta.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(apimachinery.ObjectMeta.builder()).build()
            return self._set("metadata", value)

        def spec(
            self,
            value_or_callback: Union[
                Optional[BucketSpec], Callable[[BucketSpec.Builder], BucketSpec.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(BucketSpec.builder()).build()
            return self._set("spec", value)

        def status(
            self,
            value_or_callback: Union[
                Optional[BucketStatus],
                Callable[[BucketStatus.Builder], BucketStatus.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(BucketStatus.builder()).build()
            return self._set("status", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Bucket", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Bucket.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["source.toolkit.fluxcd.io/v1beta2"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "source.toolkit.fluxcd.io/v1beta2"
    kind: Annotated[
        Optional[Literal["Bucket"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "Bucket"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[BucketSpec] = None
    status: Optional[BucketStatus] = None


class GitRepository(Resource):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["GitRepository"]:
            return GitRepository

        def build(self) -> "GitRepository":
            return GitRepository(**self._attrs)

        def api_version(self, value: Optional[Literal["source.toolkit.fluxcd.io/v1beta2"]]) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["GitRepository"]]) -> Self:
            return self._set("kind", value)

        def metadata(
            self,
            value_or_callback: Union[
                Optional[apimachinery.ObjectMeta],
                Callable[[apimachinery.ObjectMeta.Builder], apimachinery.ObjectMeta.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(apimachinery.ObjectMeta.builder()).build()
            return self._set("metadata", value)

        def spec(
            self,
            value_or_callback: Union[
                Optional[GitRepositorySpec],
                Callable[[GitRepositorySpec.Builder], GitRepositorySpec.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(GitRepositorySpec.builder()).build()
            return self._set("spec", value)

        def status(
            self,
            value_or_callback: Union[
                Optional[GitRepositoryStatus],
                Callable[[GitRepositoryStatus.Builder], GitRepositoryStatus.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(GitRepositoryStatus.builder()).build()
            return self._set("status", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["GitRepository", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GitRepository.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["source.toolkit.fluxcd.io/v1beta2"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "source.toolkit.fluxcd.io/v1beta2"
    kind: Annotated[
        Optional[Literal["GitRepository"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "GitRepository"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[GitRepositorySpec] = None
    status: Optional[GitRepositoryStatus] = None


class HelmChart(Resource):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["HelmChart"]:
            return HelmChart

        def build(self) -> "HelmChart":
            return HelmChart(**self._attrs)

        def api_version(self, value: Optional[Literal["source.toolkit.fluxcd.io/v1beta2"]]) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["HelmChart"]]) -> Self:
            return self._set("kind", value)

        def metadata(
            self,
            value_or_callback: Union[
                Optional[apimachinery.ObjectMeta],
                Callable[[apimachinery.ObjectMeta.Builder], apimachinery.ObjectMeta.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(apimachinery.ObjectMeta.builder()).build()
            return self._set("metadata", value)

        def spec(
            self,
            value_or_callback: Union[
                Optional[HelmChartSpec],
                Callable[[HelmChartSpec.Builder], HelmChartSpec.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(HelmChartSpec.builder()).build()
            return self._set("spec", value)

        def status(
            self,
            value_or_callback: Union[
                Optional[HelmChartStatus],
                Callable[[HelmChartStatus.Builder], HelmChartStatus.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(HelmChartStatus.builder()).build()
            return self._set("status", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["HelmChart", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmChart.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["source.toolkit.fluxcd.io/v1beta2"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "source.toolkit.fluxcd.io/v1beta2"
    kind: Annotated[
        Optional[Literal["HelmChart"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "HelmChart"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[HelmChartSpec] = None
    status: Optional[HelmChartStatus] = None


class HelmRepository(Resource):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["HelmRepository"]:
            return HelmRepository

        def build(self) -> "HelmRepository":
            return HelmRepository(**self._attrs)

        def api_version(self, value: Optional[Literal["source.toolkit.fluxcd.io/v1beta2"]]) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["HelmRepository"]]) -> Self:
            return self._set("kind", value)

        def metadata(
            self,
            value_or_callback: Union[
                Optional[apimachinery.ObjectMeta],
                Callable[[apimachinery.ObjectMeta.Builder], apimachinery.ObjectMeta.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(apimachinery.ObjectMeta.builder()).build()
            return self._set("metadata", value)

        def spec(
            self,
            value_or_callback: Union[
                Optional[HelmRepositorySpec],
                Callable[[HelmRepositorySpec.Builder], HelmRepositorySpec.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(HelmRepositorySpec.builder()).build()
            return self._set("spec", value)

        def status(
            self,
            value_or_callback: Union[
                Optional[HelmRepositoryStatus],
                Callable[[HelmRepositoryStatus.Builder], HelmRepositoryStatus.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(HelmRepositoryStatus.builder()).build()
            return self._set("status", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["HelmRepository", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmRepository.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["source.toolkit.fluxcd.io/v1beta2"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "source.toolkit.fluxcd.io/v1beta2"
    kind: Annotated[
        Optional[Literal["HelmRepository"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "HelmRepository"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[HelmRepositorySpec] = None
    status: Optional[HelmRepositoryStatus] = None


class OCIRepository(Resource):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["OCIRepository"]:
            return OCIRepository

        def build(self) -> "OCIRepository":
            return OCIRepository(**self._attrs)

        def api_version(self, value: Optional[Literal["source.toolkit.fluxcd.io/v1beta2"]]) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["OCIRepository"]]) -> Self:
            return self._set("kind", value)

        def metadata(
            self,
            value_or_callback: Union[
                Optional[apimachinery.ObjectMeta],
                Callable[[apimachinery.ObjectMeta.Builder], apimachinery.ObjectMeta.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(apimachinery.ObjectMeta.builder()).build()
            return self._set("metadata", value)

        def spec(
            self,
            value_or_callback: Union[
                Optional[OCIRepositorySpec],
                Callable[[OCIRepositorySpec.Builder], OCIRepositorySpec.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(OCIRepositorySpec.builder()).build()
            return self._set("spec", value)

        def status(
            self,
            value_or_callback: Union[
                Optional[OCIRepositoryStatus],
                Callable[[OCIRepositoryStatus.Builder], OCIRepositoryStatus.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(OCIRepositoryStatus.builder()).build()
            return self._set("status", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["OCIRepository", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use OCIRepository.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["source.toolkit.fluxcd.io/v1beta2"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "source.toolkit.fluxcd.io/v1beta2"
    kind: Annotated[
        Optional[Literal["OCIRepository"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "OCIRepository"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[OCIRepositorySpec] = None
    status: Optional[OCIRepositoryStatus] = None
