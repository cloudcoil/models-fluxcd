# Generated by cloudcoil-model-codegen v0.2.1
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import Annotated, Callable, Dict, List, Literal, Optional, Type, Union

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import BaseBuilder, BaseModel, GenericListBuilder, Self
from cloudcoil.resources import Resource


class NamespaceSelector(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["NamespaceSelector"]:
            return NamespaceSelector

        def build(self) -> "NamespaceSelector":
            return NamespaceSelector(**self._attrs)

        def match_labels(self, value: Optional[Dict[str, str]]) -> Self:
            return self._set("match_labels", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["NamespaceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamespaceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_labels: Annotated[
        Optional[Dict[str, str]],
        Field(
            alias="matchLabels",
            description='MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is "key", the\noperator is "In", and the values array contains only "value". The requirements are ANDed.',
        ),
    ] = None


class AccessFrom(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["AccessFrom"]:
            return AccessFrom

        def build(self) -> "AccessFrom":
            return AccessFrom(**self._attrs)

        def namespace_selectors(
            self,
            value_or_callback: Union[
                List[NamespaceSelector],
                Callable[
                    [GenericListBuilder[NamespaceSelector, NamespaceSelector.Builder]],
                    GenericListBuilder[NamespaceSelector, NamespaceSelector.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(NamespaceSelector.list_builder()).build()
            return self._set("namespace_selectors", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["AccessFrom", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AccessFrom.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    namespace_selectors: Annotated[
        List[NamespaceSelector],
        Field(
            alias="namespaceSelectors",
            description="NamespaceSelectors is the list of namespace selectors to which this ACL applies.\nItems in this list are evaluated using a logical OR operation.",
        ),
    ]


class SecretRef(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["SecretRef"]:
            return SecretRef

        def build(self) -> "SecretRef":
            return SecretRef(**self._attrs)

        def name(self, value: str) -> Self:
            return self._set("name", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["SecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Annotated[str, Field(description="Name of the referent.")]


class BucketSpec(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["BucketSpec"]:
            return BucketSpec

        def build(self) -> "BucketSpec":
            return BucketSpec(**self._attrs)

        def access_from(
            self,
            value_or_callback: Union[
                Optional[AccessFrom], Callable[[AccessFrom.Builder], AccessFrom.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(AccessFrom.builder()).build()
            return self._set("access_from", value)

        def bucket_name(self, value: str) -> Self:
            return self._set("bucket_name", value)

        def endpoint(self, value: str) -> Self:
            return self._set("endpoint", value)

        def ignore(self, value: Optional[str]) -> Self:
            return self._set("ignore", value)

        def insecure(self, value: Optional[bool]) -> Self:
            return self._set("insecure", value)

        def interval(self, value: str) -> Self:
            return self._set("interval", value)

        def provider(self, value: Optional[Literal["generic", "aws", "gcp"]]) -> Self:
            return self._set("provider", value)

        def region(self, value: Optional[str]) -> Self:
            return self._set("region", value)

        def secret_ref(
            self,
            value_or_callback: Union[
                Optional[SecretRef], Callable[[SecretRef.Builder], SecretRef.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SecretRef.builder()).build()
            return self._set("secret_ref", value)

        def suspend(self, value: Optional[bool]) -> Self:
            return self._set("suspend", value)

        def timeout(self, value: Optional[str]) -> Self:
            return self._set("timeout", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["BucketSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BucketSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_from: Annotated[
        Optional[AccessFrom],
        Field(
            alias="accessFrom",
            description="AccessFrom defines an Access Control List for allowing cross-namespace references to this object.",
        ),
    ] = None
    bucket_name: Annotated[str, Field(alias="bucketName", description="The bucket name.")]
    endpoint: Annotated[str, Field(description="The bucket endpoint address.")]
    ignore: Annotated[
        Optional[str],
        Field(
            description="Ignore overrides the set of excluded patterns in the .sourceignore format\n(which is the same as .gitignore). If not provided, a default will be used,\nconsult the documentation for your version to find out what those are."
        ),
    ] = None
    insecure: Annotated[
        Optional[bool],
        Field(description="Insecure allows connecting to a non-TLS S3 HTTP endpoint."),
    ] = None
    interval: Annotated[
        str, Field(description="The interval at which to check for bucket updates.")
    ]
    provider: Annotated[
        Optional[Literal["generic", "aws", "gcp"]],
        Field(description="The S3 compatible storage provider name, default ('generic')."),
    ] = "generic"
    region: Annotated[Optional[str], Field(description="The bucket region.")] = None
    secret_ref: Annotated[
        Optional[SecretRef],
        Field(
            alias="secretRef",
            description="The name of the secret containing authentication credentials\nfor the Bucket.",
        ),
    ] = None
    suspend: Annotated[
        Optional[bool],
        Field(
            description="This flag tells the controller to suspend the reconciliation of this source."
        ),
    ] = None
    timeout: Annotated[
        Optional[str],
        Field(description="The timeout for download operations, defaults to 60s."),
    ] = "60s"


class Artifact(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Artifact"]:
            return Artifact

        def build(self) -> "Artifact":
            return Artifact(**self._attrs)

        def checksum(self, value: Optional[str]) -> Self:
            return self._set("checksum", value)

        def last_update_time(self, value: datetime) -> Self:
            return self._set("last_update_time", value)

        def path(self, value: str) -> Self:
            return self._set("path", value)

        def revision(self, value: Optional[str]) -> Self:
            return self._set("revision", value)

        def url(self, value: str) -> Self:
            return self._set("url", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Artifact", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Artifact.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    checksum: Annotated[
        Optional[str],
        Field(description="Checksum is the SHA256 checksum of the artifact."),
    ] = None
    last_update_time: Annotated[
        datetime,
        Field(
            alias="lastUpdateTime",
            description="LastUpdateTime is the timestamp corresponding to the last update of this\nartifact.",
        ),
    ]
    path: Annotated[str, Field(description="Path is the relative file path of this artifact.")]
    revision: Annotated[
        Optional[str],
        Field(
            description="Revision is a human readable identifier traceable in the origin source\nsystem. It can be a Git commit SHA, Git tag, a Helm index timestamp, a Helm\nchart version, etc."
        ),
    ] = None
    url: Annotated[str, Field(description="URL is the HTTP address of this artifact.")]


class Condition(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: datetime) -> Self:
            return self._set("last_transition_time", value)

        def message(self, value: str) -> Self:
            return self._set("message", value)

        def observed_generation(self, value: Optional[int]) -> Self:
            return self._set("observed_generation", value)

        def reason(self, value: str) -> Self:
            return self._set("reason", value)

        def status(self, value: Literal["True", "False", "Unknown"]) -> Self:
            return self._set("status", value)

        def type(self, value: str) -> Self:
            return self._set("type", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[
        datetime,
        Field(
            alias="lastTransitionTime",
            description="lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
        ),
    ]
    message: Annotated[
        str,
        Field(
            description="message is a human readable message indicating details about the transition.\nThis may be an empty string.",
            max_length=32768,
        ),
    ]
    observed_generation: Annotated[
        Optional[int],
        Field(
            alias="observedGeneration",
            description="observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
            ge=0,
        ),
    ] = None
    reason: Annotated[
        str,
        Field(
            description="reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.",
            max_length=1024,
            min_length=1,
            pattern="^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$",
        ),
    ]
    status: Annotated[
        Literal["True", "False", "Unknown"],
        Field(description="status of the condition, one of True, False, Unknown."),
    ]
    type: Annotated[
        str,
        Field(
            description="type of condition in CamelCase or in foo.example.com/CamelCase.",
            max_length=316,
            pattern="^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$",
        ),
    ]


class BucketStatus(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["BucketStatus"]:
            return BucketStatus

        def build(self) -> "BucketStatus":
            return BucketStatus(**self._attrs)

        def artifact(
            self,
            value_or_callback: Union[
                Optional[Artifact], Callable[[Artifact.Builder], Artifact.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Artifact.builder()).build()
            return self._set("artifact", value)

        def conditions(
            self,
            value_or_callback: Union[
                Optional[List[Condition]],
                Callable[
                    [GenericListBuilder[Condition, Condition.Builder]],
                    GenericListBuilder[Condition, Condition.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Condition.list_builder()).build()
            return self._set("conditions", value)

        def last_handled_reconcile_at(self, value: Optional[str]) -> Self:
            return self._set("last_handled_reconcile_at", value)

        def observed_generation(self, value: Optional[int]) -> Self:
            return self._set("observed_generation", value)

        def url(self, value: Optional[str]) -> Self:
            return self._set("url", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["BucketStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BucketStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    artifact: Annotated[
        Optional[Artifact],
        Field(description="Artifact represents the output of the last successful Bucket sync."),
    ] = None
    conditions: Annotated[
        Optional[List[Condition]],
        Field(description="Conditions holds the conditions for the Bucket."),
    ] = None
    last_handled_reconcile_at: Annotated[
        Optional[str],
        Field(
            alias="lastHandledReconcileAt",
            description="LastHandledReconcileAt holds the value of the most recent\nreconcile request value, so a change of the annotation value\ncan be detected.",
        ),
    ] = None
    observed_generation: Annotated[
        Optional[int],
        Field(
            alias="observedGeneration",
            description="ObservedGeneration is the last observed generation.",
        ),
    ] = None
    url: Annotated[
        Optional[str],
        Field(
            description="URL is the download link for the artifact output of the last Bucket sync."
        ),
    ] = None


class Repository(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Repository"]:
            return Repository

        def build(self) -> "Repository":
            return Repository(**self._attrs)

        def name(self, value: str) -> Self:
            return self._set("name", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Repository", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Repository.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Annotated[str, Field(description="Name of the referent.")]


class Include(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Include"]:
            return Include

        def build(self) -> "Include":
            return Include(**self._attrs)

        def from_path(self, value: Optional[str]) -> Self:
            return self._set("from_path", value)

        def repository(
            self,
            value_or_callback: Union[
                Repository, Callable[[Repository.Builder], Repository.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Repository.builder()).build()
            return self._set("repository", value)

        def to_path(self, value: Optional[str]) -> Self:
            return self._set("to_path", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Include", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Include.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    from_path: Annotated[
        Optional[str],
        Field(
            alias="fromPath",
            description="The path to copy contents from, defaults to the root directory.",
        ),
    ] = None
    repository: Annotated[Repository, Field(description="Reference to a GitRepository to include.")]
    to_path: Annotated[
        Optional[str],
        Field(
            alias="toPath",
            description="The path to copy contents to, defaults to the name of the source ref.",
        ),
    ] = None


class Ref(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Ref"]:
            return Ref

        def build(self) -> "Ref":
            return Ref(**self._attrs)

        def branch(self, value: Optional[str]) -> Self:
            return self._set("branch", value)

        def commit(self, value: Optional[str]) -> Self:
            return self._set("commit", value)

        def semver(self, value: Optional[str]) -> Self:
            return self._set("semver", value)

        def tag(self, value: Optional[str]) -> Self:
            return self._set("tag", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Ref", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ref.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    branch: Annotated[
        Optional[str],
        Field(description="The Git branch to checkout, defaults to master."),
    ] = None
    commit: Annotated[
        Optional[str],
        Field(
            description="The Git commit SHA to checkout, if specified Tag filters will be ignored."
        ),
    ] = None
    semver: Annotated[
        Optional[str],
        Field(description="The Git tag semver expression, takes precedence over Tag."),
    ] = None
    tag: Annotated[
        Optional[str],
        Field(description="The Git tag to checkout, takes precedence over Branch."),
    ] = None


class Verify(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Verify"]:
            return Verify

        def build(self) -> "Verify":
            return Verify(**self._attrs)

        def mode(self, value: Literal["head"]) -> Self:
            return self._set("mode", value)

        def secret_ref(
            self,
            value_or_callback: Union[
                Optional[SecretRef], Callable[[SecretRef.Builder], SecretRef.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SecretRef.builder()).build()
            return self._set("secret_ref", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Verify", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Verify.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    mode: Annotated[
        Literal["head"],
        Field(description="Mode describes what git object should be verified, currently ('head')."),
    ]
    secret_ref: Annotated[
        Optional[SecretRef],
        Field(
            alias="secretRef",
            description="The secret name containing the public keys of all trusted Git authors.",
        ),
    ] = None


class GitRepositorySpec(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["GitRepositorySpec"]:
            return GitRepositorySpec

        def build(self) -> "GitRepositorySpec":
            return GitRepositorySpec(**self._attrs)

        def access_from(
            self,
            value_or_callback: Union[
                Optional[AccessFrom], Callable[[AccessFrom.Builder], AccessFrom.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(AccessFrom.builder()).build()
            return self._set("access_from", value)

        def git_implementation(self, value: Optional[Literal["go-git", "libgit2"]]) -> Self:
            return self._set("git_implementation", value)

        def ignore(self, value: Optional[str]) -> Self:
            return self._set("ignore", value)

        def include(
            self,
            value_or_callback: Union[
                Optional[List[Include]],
                Callable[
                    [GenericListBuilder[Include, Include.Builder]],
                    GenericListBuilder[Include, Include.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Include.list_builder()).build()
            return self._set("include", value)

        def interval(self, value: str) -> Self:
            return self._set("interval", value)

        def recurse_submodules(self, value: Optional[bool]) -> Self:
            return self._set("recurse_submodules", value)

        def ref(
            self,
            value_or_callback: Union[Optional[Ref], Callable[[Ref.Builder], Ref.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Ref.builder()).build()
            return self._set("ref", value)

        def secret_ref(
            self,
            value_or_callback: Union[
                Optional[SecretRef], Callable[[SecretRef.Builder], SecretRef.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SecretRef.builder()).build()
            return self._set("secret_ref", value)

        def suspend(self, value: Optional[bool]) -> Self:
            return self._set("suspend", value)

        def timeout(self, value: Optional[str]) -> Self:
            return self._set("timeout", value)

        def url(self, value: str) -> Self:
            return self._set("url", value)

        def verify(
            self,
            value_or_callback: Union[Optional[Verify], Callable[[Verify.Builder], Verify.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Verify.builder()).build()
            return self._set("verify", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["GitRepositorySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GitRepositorySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_from: Annotated[
        Optional[AccessFrom],
        Field(
            alias="accessFrom",
            description="AccessFrom defines an Access Control List for allowing cross-namespace references to this object.",
        ),
    ] = None
    git_implementation: Annotated[
        Optional[Literal["go-git", "libgit2"]],
        Field(
            alias="gitImplementation",
            description="Determines which git client library to use.\nDefaults to go-git, valid values are ('go-git', 'libgit2').",
        ),
    ] = "go-git"
    ignore: Annotated[
        Optional[str],
        Field(
            description="Ignore overrides the set of excluded patterns in the .sourceignore format\n(which is the same as .gitignore). If not provided, a default will be used,\nconsult the documentation for your version to find out what those are."
        ),
    ] = None
    include: Annotated[
        Optional[List[Include]],
        Field(description="Extra git repositories to map into the repository"),
    ] = None
    interval: Annotated[
        str, Field(description="The interval at which to check for repository updates.")
    ]
    recurse_submodules: Annotated[
        Optional[bool],
        Field(
            alias="recurseSubmodules",
            description="When enabled, after the clone is created, initializes all submodules within,\nusing their default settings.\nThis option is available only when using the 'go-git' GitImplementation.",
        ),
    ] = None
    ref: Annotated[
        Optional[Ref],
        Field(
            description="The Git reference to checkout and monitor for changes, defaults to\nmaster branch."
        ),
    ] = None
    secret_ref: Annotated[
        Optional[SecretRef],
        Field(
            alias="secretRef",
            description="The secret name containing the Git credentials.\nFor HTTPS repositories the secret must contain username and password\nfields.\nFor SSH repositories the secret must contain identity and known_hosts\nfields.",
        ),
    ] = None
    suspend: Annotated[
        Optional[bool],
        Field(
            description="This flag tells the controller to suspend the reconciliation of this source."
        ),
    ] = None
    timeout: Annotated[
        Optional[str],
        Field(description="The timeout for remote Git operations like cloning, defaults to 60s."),
    ] = "60s"
    url: Annotated[
        str,
        Field(
            description="The repository URL, can be a HTTP/S or SSH address.",
            pattern="^(http|https|ssh)://.*$",
        ),
    ]
    verify: Annotated[
        Optional[Verify],
        Field(description="Verify OpenPGP signature for the Git commit HEAD points to."),
    ] = None


class IncludedArtifact(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["IncludedArtifact"]:
            return IncludedArtifact

        def build(self) -> "IncludedArtifact":
            return IncludedArtifact(**self._attrs)

        def checksum(self, value: Optional[str]) -> Self:
            return self._set("checksum", value)

        def last_update_time(self, value: datetime) -> Self:
            return self._set("last_update_time", value)

        def path(self, value: str) -> Self:
            return self._set("path", value)

        def revision(self, value: Optional[str]) -> Self:
            return self._set("revision", value)

        def url(self, value: str) -> Self:
            return self._set("url", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["IncludedArtifact", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IncludedArtifact.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    checksum: Annotated[
        Optional[str],
        Field(description="Checksum is the SHA256 checksum of the artifact."),
    ] = None
    last_update_time: Annotated[
        datetime,
        Field(
            alias="lastUpdateTime",
            description="LastUpdateTime is the timestamp corresponding to the last update of this\nartifact.",
        ),
    ]
    path: Annotated[str, Field(description="Path is the relative file path of this artifact.")]
    revision: Annotated[
        Optional[str],
        Field(
            description="Revision is a human readable identifier traceable in the origin source\nsystem. It can be a Git commit SHA, Git tag, a Helm index timestamp, a Helm\nchart version, etc."
        ),
    ] = None
    url: Annotated[str, Field(description="URL is the HTTP address of this artifact.")]


class GitRepositoryStatus(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["GitRepositoryStatus"]:
            return GitRepositoryStatus

        def build(self) -> "GitRepositoryStatus":
            return GitRepositoryStatus(**self._attrs)

        def artifact(
            self,
            value_or_callback: Union[
                Optional[Artifact], Callable[[Artifact.Builder], Artifact.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Artifact.builder()).build()
            return self._set("artifact", value)

        def conditions(
            self,
            value_or_callback: Union[
                Optional[List[Condition]],
                Callable[
                    [GenericListBuilder[Condition, Condition.Builder]],
                    GenericListBuilder[Condition, Condition.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Condition.list_builder()).build()
            return self._set("conditions", value)

        def included_artifacts(
            self,
            value_or_callback: Union[
                Optional[List[IncludedArtifact]],
                Callable[
                    [GenericListBuilder[IncludedArtifact, IncludedArtifact.Builder]],
                    GenericListBuilder[IncludedArtifact, IncludedArtifact.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(IncludedArtifact.list_builder()).build()
            return self._set("included_artifacts", value)

        def last_handled_reconcile_at(self, value: Optional[str]) -> Self:
            return self._set("last_handled_reconcile_at", value)

        def observed_generation(self, value: Optional[int]) -> Self:
            return self._set("observed_generation", value)

        def url(self, value: Optional[str]) -> Self:
            return self._set("url", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["GitRepositoryStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GitRepositoryStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    artifact: Annotated[
        Optional[Artifact],
        Field(description="Artifact represents the output of the last successful repository sync."),
    ] = None
    conditions: Annotated[
        Optional[List[Condition]],
        Field(description="Conditions holds the conditions for the GitRepository."),
    ] = None
    included_artifacts: Annotated[
        Optional[List[IncludedArtifact]],
        Field(
            alias="includedArtifacts",
            description="IncludedArtifacts represents the included artifacts from the last successful repository sync.",
        ),
    ] = None
    last_handled_reconcile_at: Annotated[
        Optional[str],
        Field(
            alias="lastHandledReconcileAt",
            description="LastHandledReconcileAt holds the value of the most recent\nreconcile request value, so a change of the annotation value\ncan be detected.",
        ),
    ] = None
    observed_generation: Annotated[
        Optional[int],
        Field(
            alias="observedGeneration",
            description="ObservedGeneration is the last observed generation.",
        ),
    ] = None
    url: Annotated[
        Optional[str],
        Field(
            description="URL is the download link for the artifact output of the last repository\nsync."
        ),
    ] = None


class SourceRef(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["SourceRef"]:
            return SourceRef

        def build(self) -> "SourceRef":
            return SourceRef(**self._attrs)

        def api_version(self, value: Optional[str]) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Literal["HelmRepository", "GitRepository", "Bucket"]) -> Self:
            return self._set("kind", value)

        def name(self, value: str) -> Self:
            return self._set("name", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["SourceRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SourceRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[str],
        Field(alias="apiVersion", description="APIVersion of the referent."),
    ] = None
    kind: Annotated[
        Literal["HelmRepository", "GitRepository", "Bucket"],
        Field(
            description="Kind of the referent, valid values are ('HelmRepository', 'GitRepository',\n'Bucket')."
        ),
    ]
    name: Annotated[str, Field(description="Name of the referent.")]


class HelmChartSpec(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["HelmChartSpec"]:
            return HelmChartSpec

        def build(self) -> "HelmChartSpec":
            return HelmChartSpec(**self._attrs)

        def access_from(
            self,
            value_or_callback: Union[
                Optional[AccessFrom], Callable[[AccessFrom.Builder], AccessFrom.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(AccessFrom.builder()).build()
            return self._set("access_from", value)

        def chart(self, value: str) -> Self:
            return self._set("chart", value)

        def interval(self, value: str) -> Self:
            return self._set("interval", value)

        def reconcile_strategy(self, value: Optional[Literal["ChartVersion", "Revision"]]) -> Self:
            return self._set("reconcile_strategy", value)

        def source_ref(
            self,
            value_or_callback: Union[SourceRef, Callable[[SourceRef.Builder], SourceRef.Builder]],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SourceRef.builder()).build()
            return self._set("source_ref", value)

        def suspend(self, value: Optional[bool]) -> Self:
            return self._set("suspend", value)

        def values_file(self, value: Optional[str]) -> Self:
            return self._set("values_file", value)

        def values_files(self, value: Optional[List[str]]) -> Self:
            return self._set("values_files", value)

        def version(self, value: Optional[str]) -> Self:
            return self._set("version", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["HelmChartSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmChartSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_from: Annotated[
        Optional[AccessFrom],
        Field(
            alias="accessFrom",
            description="AccessFrom defines an Access Control List for allowing cross-namespace references to this object.",
        ),
    ] = None
    chart: Annotated[
        str,
        Field(description="The name or path the Helm chart is available at in the SourceRef."),
    ]
    interval: Annotated[
        str, Field(description="The interval at which to check the Source for updates.")
    ]
    reconcile_strategy: Annotated[
        Optional[Literal["ChartVersion", "Revision"]],
        Field(
            alias="reconcileStrategy",
            description="Determines what enables the creation of a new artifact. Valid values are\n('ChartVersion', 'Revision').\nSee the documentation of the values for an explanation on their behavior.\nDefaults to ChartVersion when omitted.",
        ),
    ] = "ChartVersion"
    source_ref: Annotated[
        SourceRef,
        Field(
            alias="sourceRef",
            description="The reference to the Source the chart is available at.",
        ),
    ]
    suspend: Annotated[
        Optional[bool],
        Field(
            description="This flag tells the controller to suspend the reconciliation of this source."
        ),
    ] = None
    values_file: Annotated[
        Optional[str],
        Field(
            alias="valuesFile",
            description="Alternative values file to use as the default chart values, expected to\nbe a relative path in the SourceRef. Deprecated in favor of ValuesFiles,\nfor backwards compatibility the file defined here is merged before the\nValuesFiles items. Ignored when omitted.",
        ),
    ] = None
    values_files: Annotated[
        Optional[List[str]],
        Field(
            alias="valuesFiles",
            description="Alternative list of values files to use as the chart values (values.yaml\nis not included by default), expected to be a relative path in the SourceRef.\nValues files are merged in the order of this list with the last file overriding\nthe first. Ignored when omitted.",
        ),
    ] = None
    version: Annotated[
        Optional[str],
        Field(
            description="The chart version semver expression, ignored for charts from GitRepository\nand Bucket sources. Defaults to latest when omitted."
        ),
    ] = "*"


class HelmChartStatus(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["HelmChartStatus"]:
            return HelmChartStatus

        def build(self) -> "HelmChartStatus":
            return HelmChartStatus(**self._attrs)

        def artifact(
            self,
            value_or_callback: Union[
                Optional[Artifact], Callable[[Artifact.Builder], Artifact.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Artifact.builder()).build()
            return self._set("artifact", value)

        def conditions(
            self,
            value_or_callback: Union[
                Optional[List[Condition]],
                Callable[
                    [GenericListBuilder[Condition, Condition.Builder]],
                    GenericListBuilder[Condition, Condition.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Condition.list_builder()).build()
            return self._set("conditions", value)

        def last_handled_reconcile_at(self, value: Optional[str]) -> Self:
            return self._set("last_handled_reconcile_at", value)

        def observed_generation(self, value: Optional[int]) -> Self:
            return self._set("observed_generation", value)

        def url(self, value: Optional[str]) -> Self:
            return self._set("url", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["HelmChartStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmChartStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    artifact: Annotated[
        Optional[Artifact],
        Field(description="Artifact represents the output of the last successful chart sync."),
    ] = None
    conditions: Annotated[
        Optional[List[Condition]],
        Field(description="Conditions holds the conditions for the HelmChart."),
    ] = None
    last_handled_reconcile_at: Annotated[
        Optional[str],
        Field(
            alias="lastHandledReconcileAt",
            description="LastHandledReconcileAt holds the value of the most recent\nreconcile request value, so a change of the annotation value\ncan be detected.",
        ),
    ] = None
    observed_generation: Annotated[
        Optional[int],
        Field(
            alias="observedGeneration",
            description="ObservedGeneration is the last observed generation.",
        ),
    ] = None
    url: Annotated[
        Optional[str],
        Field(description="URL is the download link for the last chart pulled."),
    ] = None


class HelmRepositorySpec(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["HelmRepositorySpec"]:
            return HelmRepositorySpec

        def build(self) -> "HelmRepositorySpec":
            return HelmRepositorySpec(**self._attrs)

        def access_from(
            self,
            value_or_callback: Union[
                Optional[AccessFrom], Callable[[AccessFrom.Builder], AccessFrom.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(AccessFrom.builder()).build()
            return self._set("access_from", value)

        def interval(self, value: str) -> Self:
            return self._set("interval", value)

        def pass_credentials(self, value: Optional[bool]) -> Self:
            return self._set("pass_credentials", value)

        def secret_ref(
            self,
            value_or_callback: Union[
                Optional[SecretRef], Callable[[SecretRef.Builder], SecretRef.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(SecretRef.builder()).build()
            return self._set("secret_ref", value)

        def suspend(self, value: Optional[bool]) -> Self:
            return self._set("suspend", value)

        def timeout(self, value: Optional[str]) -> Self:
            return self._set("timeout", value)

        def url(self, value: str) -> Self:
            return self._set("url", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["HelmRepositorySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmRepositorySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_from: Annotated[
        Optional[AccessFrom],
        Field(
            alias="accessFrom",
            description="AccessFrom defines an Access Control List for allowing cross-namespace references to this object.",
        ),
    ] = None
    interval: Annotated[
        str,
        Field(description="The interval at which to check the upstream for updates."),
    ]
    pass_credentials: Annotated[
        Optional[bool],
        Field(
            alias="passCredentials",
            description="PassCredentials allows the credentials from the SecretRef to be passed on to\na host that does not match the host as defined in URL.\nThis may be required if the host of the advertised chart URLs in the index\ndiffer from the defined URL.\nEnabling this should be done with caution, as it can potentially result in\ncredentials getting stolen in a MITM-attack.",
        ),
    ] = None
    secret_ref: Annotated[
        Optional[SecretRef],
        Field(
            alias="secretRef",
            description="The name of the secret containing authentication credentials for the Helm\nrepository.\nFor HTTP/S basic auth the secret must contain username and\npassword fields.\nFor TLS the secret must contain a certFile and keyFile, and/or\ncaFile fields.",
        ),
    ] = None
    suspend: Annotated[
        Optional[bool],
        Field(
            description="This flag tells the controller to suspend the reconciliation of this source."
        ),
    ] = None
    timeout: Annotated[
        Optional[str],
        Field(description="The timeout of index downloading, defaults to 60s."),
    ] = "60s"
    url: Annotated[
        str,
        Field(
            description="The Helm repository URL, a valid URL contains at least a protocol and host."
        ),
    ]


class HelmRepositoryStatus(BaseModel):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["HelmRepositoryStatus"]:
            return HelmRepositoryStatus

        def build(self) -> "HelmRepositoryStatus":
            return HelmRepositoryStatus(**self._attrs)

        def artifact(
            self,
            value_or_callback: Union[
                Optional[Artifact], Callable[[Artifact.Builder], Artifact.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Artifact.builder()).build()
            return self._set("artifact", value)

        def conditions(
            self,
            value_or_callback: Union[
                Optional[List[Condition]],
                Callable[
                    [GenericListBuilder[Condition, Condition.Builder]],
                    GenericListBuilder[Condition, Condition.Builder],
                ],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(Condition.list_builder()).build()
            return self._set("conditions", value)

        def last_handled_reconcile_at(self, value: Optional[str]) -> Self:
            return self._set("last_handled_reconcile_at", value)

        def observed_generation(self, value: Optional[int]) -> Self:
            return self._set("observed_generation", value)

        def url(self, value: Optional[str]) -> Self:
            return self._set("url", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["HelmRepositoryStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmRepositoryStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    artifact: Annotated[
        Optional[Artifact],
        Field(description="Artifact represents the output of the last successful repository sync."),
    ] = None
    conditions: Annotated[
        Optional[List[Condition]],
        Field(description="Conditions holds the conditions for the HelmRepository."),
    ] = None
    last_handled_reconcile_at: Annotated[
        Optional[str],
        Field(
            alias="lastHandledReconcileAt",
            description="LastHandledReconcileAt holds the value of the most recent\nreconcile request value, so a change of the annotation value\ncan be detected.",
        ),
    ] = None
    observed_generation: Annotated[
        Optional[int],
        Field(
            alias="observedGeneration",
            description="ObservedGeneration is the last observed generation.",
        ),
    ] = None
    url: Annotated[
        Optional[str],
        Field(description="URL is the download link for the last index fetched."),
    ] = None


class Bucket(Resource):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["Bucket"]:
            return Bucket

        def build(self) -> "Bucket":
            return Bucket(**self._attrs)

        def api_version(self, value: Optional[Literal["source.toolkit.fluxcd.io/v1beta1"]]) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Bucket"]]) -> Self:
            return self._set("kind", value)

        def metadata(
            self,
            value_or_callback: Union[
                Optional[apimachinery.ObjectMeta],
                Callable[[apimachinery.ObjectMeta.Builder], apimachinery.ObjectMeta.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(apimachinery.ObjectMeta.builder()).build()
            return self._set("metadata", value)

        def spec(
            self,
            value_or_callback: Union[
                Optional[BucketSpec], Callable[[BucketSpec.Builder], BucketSpec.Builder]
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(BucketSpec.builder()).build()
            return self._set("spec", value)

        def status(
            self,
            value_or_callback: Union[
                Optional[BucketStatus],
                Callable[[BucketStatus.Builder], BucketStatus.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(BucketStatus.builder()).build()
            return self._set("status", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["Bucket", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Bucket.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["source.toolkit.fluxcd.io/v1beta1"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "source.toolkit.fluxcd.io/v1beta1"
    kind: Annotated[
        Optional[Literal["Bucket"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "Bucket"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[BucketSpec] = None
    status: Optional[BucketStatus] = None


class GitRepository(Resource):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["GitRepository"]:
            return GitRepository

        def build(self) -> "GitRepository":
            return GitRepository(**self._attrs)

        def api_version(self, value: Optional[Literal["source.toolkit.fluxcd.io/v1beta1"]]) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["GitRepository"]]) -> Self:
            return self._set("kind", value)

        def metadata(
            self,
            value_or_callback: Union[
                Optional[apimachinery.ObjectMeta],
                Callable[[apimachinery.ObjectMeta.Builder], apimachinery.ObjectMeta.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(apimachinery.ObjectMeta.builder()).build()
            return self._set("metadata", value)

        def spec(
            self,
            value_or_callback: Union[
                Optional[GitRepositorySpec],
                Callable[[GitRepositorySpec.Builder], GitRepositorySpec.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(GitRepositorySpec.builder()).build()
            return self._set("spec", value)

        def status(
            self,
            value_or_callback: Union[
                Optional[GitRepositoryStatus],
                Callable[[GitRepositoryStatus.Builder], GitRepositoryStatus.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(GitRepositoryStatus.builder()).build()
            return self._set("status", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["GitRepository", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GitRepository.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["source.toolkit.fluxcd.io/v1beta1"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "source.toolkit.fluxcd.io/v1beta1"
    kind: Annotated[
        Optional[Literal["GitRepository"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "GitRepository"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[GitRepositorySpec] = None
    status: Optional[GitRepositoryStatus] = None


class HelmChart(Resource):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["HelmChart"]:
            return HelmChart

        def build(self) -> "HelmChart":
            return HelmChart(**self._attrs)

        def api_version(self, value: Optional[Literal["source.toolkit.fluxcd.io/v1beta1"]]) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["HelmChart"]]) -> Self:
            return self._set("kind", value)

        def metadata(
            self,
            value_or_callback: Union[
                Optional[apimachinery.ObjectMeta],
                Callable[[apimachinery.ObjectMeta.Builder], apimachinery.ObjectMeta.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(apimachinery.ObjectMeta.builder()).build()
            return self._set("metadata", value)

        def spec(
            self,
            value_or_callback: Union[
                Optional[HelmChartSpec],
                Callable[[HelmChartSpec.Builder], HelmChartSpec.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(HelmChartSpec.builder()).build()
            return self._set("spec", value)

        def status(
            self,
            value_or_callback: Union[
                Optional[HelmChartStatus],
                Callable[[HelmChartStatus.Builder], HelmChartStatus.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(HelmChartStatus.builder()).build()
            return self._set("status", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["HelmChart", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmChart.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["source.toolkit.fluxcd.io/v1beta1"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "source.toolkit.fluxcd.io/v1beta1"
    kind: Annotated[
        Optional[Literal["HelmChart"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "HelmChart"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[HelmChartSpec] = None
    status: Optional[HelmChartStatus] = None


class HelmRepository(Resource):
    class Builder(BaseBuilder):
        @property
        def base_class(self) -> Type["HelmRepository"]:
            return HelmRepository

        def build(self) -> "HelmRepository":
            return HelmRepository(**self._attrs)

        def api_version(self, value: Optional[Literal["source.toolkit.fluxcd.io/v1beta1"]]) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["HelmRepository"]]) -> Self:
            return self._set("kind", value)

        def metadata(
            self,
            value_or_callback: Union[
                Optional[apimachinery.ObjectMeta],
                Callable[[apimachinery.ObjectMeta.Builder], apimachinery.ObjectMeta.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(apimachinery.ObjectMeta.builder()).build()
            return self._set("metadata", value)

        def spec(
            self,
            value_or_callback: Union[
                Optional[HelmRepositorySpec],
                Callable[[HelmRepositorySpec.Builder], HelmRepositorySpec.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(HelmRepositorySpec.builder()).build()
            return self._set("spec", value)

        def status(
            self,
            value_or_callback: Union[
                Optional[HelmRepositoryStatus],
                Callable[[HelmRepositoryStatus.Builder], HelmRepositoryStatus.Builder],
            ],
        ) -> Self:
            value = value_or_callback
            if callable(value_or_callback):
                value = value_or_callback(HelmRepositoryStatus.builder()).build()
            return self._set("status", value)

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    class ListBuilder(GenericListBuilder["HelmRepository", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmRepository.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["source.toolkit.fluxcd.io/v1beta1"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "source.toolkit.fluxcd.io/v1beta1"
    kind: Annotated[
        Optional[Literal["HelmRepository"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "HelmRepository"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[HelmRepositorySpec] = None
    status: Optional[HelmRepositoryStatus] = None
